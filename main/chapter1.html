
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>1 First Chapter Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="./" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Understanding the Trusted Boot Chain Implementation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="chapter1.html">
            
                <a href="chapter1.html#1-first-chapter">
            
                    
                    1 First Chapter
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="2.1" >
            
                <span>
            
                    
                    Tables
            
                </span>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="3.1" >
            
                <span>
            
                    
                    Figures
            
                </span>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >1 First Chapter</a>
    </h1>
</div>
<div>
    <!-- 
    <img style="float:left; align:middle; height:2em" src="media/TianocoreTitlePageLogo.jpg"/>
     -->
    
      <h2>
        <div style="position:absolute;text-align:left">Understanding the Trusted Boot Chain Implementation</div>
        <div style="position:absolute;width:100%;text-align:center">DRAFT [12/02/2020 10:55:54]</div>
        <div style="text-align:right">Revision 1.0</div>
      </h2>  
    
    <hr>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <!--- @file
  Understanding the Trusted Boot Chain Implementation

  Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>

  Redistribution and use in source (original document form) and 'compiled'
  forms (converted to PDF, epub, HTML and other formats) with or without
  modification, are permitted provided that the following conditions are met:

  1) Redistributions of source code (original document form) must retain the
     above copyright notice, this list of conditions and the following
     disclaimer as the first lines of this file unmodified.

  2) Redistributions in compiled form (transformed to other DTDs, converted to
     PDF, epub, HTML and other formats) must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.

  THIS DOCUMENTATION IS PROVIDED BY TIANOCORE PROJECT "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
  EVENT SHALL TIANOCORE PROJECT  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF
  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-->
<p><strong>Understanding the Trusted Boot Chain Implementation</strong></p>
<p>Jiewen Yao</p>
<p>Intel Corporation</p>
<p>Vincent J. Zimmer</p>
<p>Intel Corporation</p>
<p><strong>November 2020</strong></p>
<h1 id="executive-summary">Executive Summary</h1>
<p>This document explains how to implement the Trusted Computing Group
(TCG) static trusted boot chain, using the TianoCore EDK II project.</p>
<p><strong>Prerequisite</strong></p>
<p>This document assumes that the audience has basic firmware development
experience using UEFI &amp; EDK II, along with basic knowledge of the UEFI
boot flow, Trusted Platform Module (TPM) and cryptography.</p>
<h1 id="table-of-contents .TOC-Heading">Table of Contents </h1>
<p><a href="#overview">Overview 6</a></p>
<p><a href="#tcg-trusted-boot-chain-in-edk-ii">TCG Trusted Boot Chain in EDK II 8</a></p>
<p><a href="#trusted-boot-flow">Trusted Boot Flow 8</a></p>
<p><a href="#pcr-measurement-and-attestation">PCR, Measurement, and Attestation 8</a></p>
<p><a href="#general-guideline">General Guideline 8</a></p>
<p><a href="#pcr-0">PCR 0 12</a></p>
<p><a href="#pcr-1">PCR 1 15</a></p>
<p><a href="#pcr-2">PCR 2 16</a></p>
<p><a href="#pcr-3">PCR 3 16</a></p>
<p><a href="#pcr-4">PCR 4 16</a></p>
<p><a href="#pcr-5">PCR 5 17</a></p>
<p><a href="#pcr-6">PCR 6 17</a></p>
<p><a href="#pcr-7">PCR 7 17</a></p>
<p><a href="#no_action-event">NO_ACTION event 18</a></p>
<p><a href="#event-log">Event Log 18</a></p>
<p><a href="#hardware-root-of-trust">Hardware Root of Trust 19</a></p>
<p><a href="#trusted-boot-chain-putting-it-all-together">Trusted Boot Chain -- Putting it all together
19</a></p>
<p><a href="#remote-attestation">Remote Attestation 20</a></p>
<p><a href="#tpm-device-startup">TPM Device Startup 23</a></p>
<p><a href="#tpm-device-selection">TPM Device Selection 24</a></p>
<p><a href="#tpm-device-interface">TPM Device Interface 24</a></p>
<p><a href="#error-handling">Error Handling 25</a></p>
<p><a href="#tcg-physical-presence">TCG Physical Presence 26</a></p>
<p><a href="#tpm-bank-selection">TPM Bank Selection 27</a></p>
<p><a href="#tpm-hierarchy-management">TPM Hierarchy Management 30</a></p>
<p><a href="#tcg-memory-overwrite-mor">TCG Memory Overwrite (MOR) 31</a></p>
<p><a href="#os-interface">OS Interface 33</a></p>
<p><a href="#acpi-table">ACPI Table 33</a></p>
<p><a href="#tcg2_protocol">TCG2_PROTOCOL 34</a></p>
<p><a href="#tcg-storage">TCG Storage 35</a></p>
<p><a href="#opal-password">OPAL Password 35</a></p>
<p><a href="#opal-features">OPAL Features 37</a></p>
<p><a href="#blocksid">BlockSid 38</a></p>
<p><a href="#tper-reset">TPer reset 39</a></p>
<p><a href="#other-trusted-boot-chains">Other Trusted Boot chains 40</a></p>
<p><a href="#coreboot">coreboot 40</a></p>
<p><a href="#grub2">Grub2 41</a></p>
<p><a href="#linux-secure-boot-shim">Linux Secure Boot Shim 41</a></p>
<p><a href="#windows-bitlocker">Windows BitLocker 42</a></p>
<p><a href="#looking-forward">Looking Forward 43</a></p>
<p><a href="#platform-root-of-trust---cerberus">Platform Root of Trust - Cerberus
43</a></p>
<p><a href="#device-root-of-trust---dice">Device Root of Trust - DICE 43</a></p>
<p><a href="#server-management-domain-firmware">Server Management Domain Firmware
45</a></p>
<p><a href="#secure-communication-spdm">Secure communication -- SPDM 46</a></p>
<p><a href="#an-open-trusted-platform-putting-it-all-together">An Open Trusted Platform -- Putting it all together
47</a></p>
<p><a href="#checklist-for-the-platform-developer">Checklist for the Platform Developer
49</a></p>
<p><a href="#pcr-measurement-and-attestation-1">PCR, Measurement and Attestation
49</a></p>
<p><a href="#general-guideline-1">General Guideline 49</a></p>
<p><a href="#pcr-0-1">PCR 0 49</a></p>
<p><a href="#pcr-1-1">PCR 1 49</a></p>
<p><a href="#pcr-2-1">PCR 2 50</a></p>
<p><a href="#pcr-3-1">PCR 3 50</a></p>
<p><a href="#pcr-4-1">PCR 4 50</a></p>
<p><a href="#pcr-5-1">PCR 5 50</a></p>
<p><a href="#pcr-6-1">PCR 6 50</a></p>
<p><a href="#pcr-7-1">PCR 7 50</a></p>
<p><a href="#no_action-event-1">NO_ACTION event 51</a></p>
<p><a href="#tpm-device-startup-1">TPM Device Startup 51</a></p>
<p><a href="#device-selection">Device Selection 51</a></p>
<p><a href="#tpm-device-interface-1">TPM Device Interface 51</a></p>
<p><a href="#error-handling-1">Error Handling 51</a></p>
<p><a href="#tcg-physical-presence-1">TCG Physical Presence 51</a></p>
<p><a href="#tpm-bank-selection-1">TPM Bank Selection 51</a></p>
<p><a href="#tpm-hierarchy-management-1">TPM Hierarchy Management 52</a></p>
<p><a href="#tcg-memory-override">TCG Memory Override 52</a></p>
<p><a href="#os-interface-1">OS Interface 52</a></p>
<p><a href="#acpi-table-1">ACPI Table 52</a></p>
<p><a href="#tcg2_protocol-1">TCG2_PROTOCOL 52</a></p>
<p><a href="#tcg-storage-1">TCG Storage 53</a></p>
<p><a href="#opal-password-1">OPAL Password 53</a></p>
<p><a href="#opal-feature">OPAL Feature 53</a></p>
<p><a href="#blocksid-1">BlockSid 53</a></p>
<p><a href="#tper-reset-1">TPer reset 53</a></p>
<p><a href="#glossary">Glossary 54</a></p>
<p><a href="#references">References 56</a></p>
<p><a href="#books">Books 56</a></p>
<p><a href="#specifications">Specifications 56</a></p>
<p><a href="#internet-links">Internet Links 58</a></p>
<h1 id="overview">Overview</h1>
<p>System firmware (BIOS/UEFI) plays an important role in computer platform
security. If the system firmware or configuration is altered from the
intended state, the system may experience loss of confidentiality,
integrity, and availability, including system instability, system
failure, and information leakage. Detecting a firmware code or
configuration change is of great importance, and can be accomplished by
measuring and monitoring firmware integrity.</p>
<p>In 2011, the National Institute of Standards and Technology
(<a href="https://www.nist.gov/" target="_blank">NIST</a>) published a draft version BIOS Integrity
Measurement Guidelines
(<a href="https://csrc.nist.gov/publications/detail/sp/800-155/draft" target="_blank">SP800-155</a>).
More recently, the Trusted Computing Group
(<a href="https://trustedcomputinggroup.org/" target="_blank">TCG</a>) has developed the following
documents to discuss firmware integrity measurement:</p>
<ul>
<li><p>TCG Reference Integrity Manifest Information Model
(<a href="https://trustedcomputinggroup.org/resource/tcg-reference-integrity-manifest-rim-information-model/" target="_blank">RIM-IM</a>)</p>
</li>
<li><p>TCG PC Client Reference Integrity Manifest
(<a href="https://trustedcomputinggroup.org/resource/tcg-pc-client-reference-integrity-manifest-specification/" target="_blank">PC-RIM</a>)</p>
</li>
<li><p>PC Client Platform Firmware Profile
(<a href="https://trustedcomputinggroup.org/resource/pc-client-specific-platform-firmware-profile-specification/" target="_blank">PFP</a>)</p>
</li>
<li><p>PC Client Platform Firmware Integrity Measurement
(<a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_FIM_v1_r40_02dec2020.pdf" target="_blank">FIM</a>) -
Draft</p>
</li>
</ul>
<p>The relationship between the above documents is as follows:</p>
<ul>
<li><p>The NIST SP800-155 specification provides a general guideline on
requirements. It does not describe implementation details.</p>
</li>
<li><p>The TCG RIM-IM specification defines the Reference Integrity
Manifest (RIM) structure that a Verifier uses to validate expected
values (Assertions) against actual values (Evidence).</p>
</li>
<li><p>The TCG PC Client RIM specification complements the TCG RIM-IM
specification and describes the RIM file formats, RIM storage
locations within the PC Client, and provides references for the
content of the RIM support files.</p>
</li>
<li><p>The TCG PFP defines the implementation for a PC client firmware
architecture. It defines how the platform firmware measures the
firmware components into Trusted Platform Module (TPM) Platform
Configuration Register (PCR) and how the firmware records the
actions in an event log.</p>
</li>
<li><p>The TCG FIM draft specification provides a framework for determining
the configuration of the hardware and the identity of the firmware
which has executed to initialize the endpoint into a booted state. A
FIM compliant platform shall implement the TCG PFP specification in
order to provide runtime evidence and the platform shall also
provide assertions based upon the TCG RIM specification.</p>
</li>
</ul>
<p>In this document, we will focus on the TCG Platform Firmware Profile
specification. The PFP specification defines how a platform firmware
contributes to the Root of Trust for Measurement (RTM) of the platform
through extending digests (measurements) of code into a TPM Platform
Configuration Register (PCR). The PFP specification also provides the
documentation of that measurement in an event log.</p>
<p>Figure 1 below shows a simple example of the firmware validation
process. An Original Equipment Manufacturer (OEM) provides a RIM as the
assertion to describe the system platform. When a corresponding system
boots, the platform firmware measures the component into some TPM PCR&apos;s
and generates an event log as evidence. The whole platform acts as an
attester and presents the event log and PCR&apos;s as evidence to a verifier.
Then the verifier can compare the evidence (event log and PCRs) and
compare it with the assertion (RIM manifest).</p>
<blockquote>
<p><img src="media/image1.png" alt="">{width=&quot;6.5in&quot;
height=&quot;4.319444444444445in&quot;}</p>
</blockquote>
<p><em>Figure 1. Measurement and Attestation</em></p>
<blockquote>
<p>A verifier can use various policies to determine the state of the
platform. Some example policies include the following:</p>
</blockquote>
<ul>
<li><p>All event log match - It means the platform is expected to meet all
of the expected values.</p>
</li>
<li><p>Event log on code (PCR0) and security policy (PCR7) match but the
configuration data (PCR1) has a mismatch -- It means someone changed
the BIOS setup configuration.</p>
</li>
<li><p>Event log on security policy (PCR7) match but code (PCR0) mismatches
-- It means someone has updated the platform firmware code.</p>
</li>
<li><p>All event log mismatch -- It means the platform is not in the
expected code or configuration state.</p>
</li>
</ul>
<h1 id="tcg-trusted-boot-chain-in-edk-ii">TCG Trusted Boot Chain in EDK II</h1>
<h2 id="trusted-boot-flow">Trusted Boot Flow</h2>
<p>Trusted boot flow is activity that the host platform firmware measures,
including firmware components, into the Trusted Platform Module (TPM)
Platform Configuration Register (PCR), and records the actions in an
event log. The TPM acts as a static Root of Trust for Storage (RTS) and
Root of Trust for Reporting (RTR). The platform firmware here acts as a
Static Root of Trust for Measurement (SRTM).</p>
<p>In this document, we use TPM 2.0 as an example. Unless otherwise
specified, the term TPM below refers to a TPM 2.0 device.</p>
<h2 id="pcr-measurement-and-attestation">PCR, Measurement, and Attestation</h2>
<p>The TPM PCRs hold the values of the data measurement. The measurement
follows the equation below. This operation is PCR extend.</p>
<p><em>PCR ~(new)~ = HASH (PCR~(old)~ || HASH(Data))</em></p>
<p>PCR extend is the only way to modify the PCR value. If a platform
extends a PCR multiple times, all data is hashed into the PCR. The
vertical bars in parentheses designate the catenation of the old and new
data, respectively.</p>
<h3 id="general-guideline">General Guideline</h3>
<p>A typical TPM has 24 PCRs. PCRs [0-15] represent the SRTM and are
associated with Locality 0. PCRs [0-7] are used for platform firmware
and PCRs [8-15] are used for the operating system. PCR [16] is for
debug usage. PCR [23] is for application support. PCRs [17-22]
represent the platform&apos;s dynamic root of trust for measurement (DRTM).
In this document we will focus on the usage of PCRs [0-7], as
described in the following table.</p>
<p>Table 1: TPM PCR Usage (Source: <a href="https://trustedcomputinggroup.org/resource/pc-client-specific-platform-firmware-profile-specification/" target="_blank">TCG PFP
Specification</a>)</p>
<p>  <strong>PCR Index</strong>   <strong>PCR Usage</strong></p>
<hr>
<p>  0               SRTM, BIOS, Host Platform Extensions, Embedded Option ROMs and PI Drivers
  1               Host Platform Configuration
  2               UEFI driver and application Code
  3               UEFI driver and application Configuration and Data
  4               UEFI Boot Manager Code (usually the MBR) and Boot Attempts
  5               Boot Manager Code Configuration and Data (for use by the Boot Manager Code) and GPT/Partition Table
  6               Host Platform Manufacturer Specific
  7               Secure Boot Policy, Secure boot Verification Authority</p>
<p>The following figure shows the high-level components and measurements.</p>
<p><img src="media/image2.png" alt="">{width=&quot;6.492361111111111in&quot;
height=&quot;4.098611111111111in&quot;}</p>
<p><em>Figure 2 -- High-level components and measurements\
(See Building Secure Firmware by Jiewen Yao &amp; Vincent Zimmer)</em></p>
<p>There is an easy way to remember Table 1, as described by the following
two rules:</p>
<p>1)  Even-numbered PCRs are for the code, while odd-numbered PCRs are for
    configuration data.</p>
<p>2)  PCRs [0-1] are for the OEM, PCRs [2-3] are for third party
    usage, PCRs [4-5] are for OS boot, PCR[7] is for secure boot
    policy, PCR[6] is undefined by the PFP spec and is
    platform-specific.</p>
<p>Table 2. PCR usage (simple rules)</p>
<pre><code>                   Code       Data Configuration
</code></pre><hr>
<p>  OEM                  PCR[0]   PCR[1]
  Third party          PCR[2]   PCR[3]
  OS Boot              PCR[4]   PCR[5]
  Secure Boot Policy   N/A        PCR[7]</p>
<p>For example:</p>
<ul>
<li><p>Any <strong>PEI, DXE, and SMM code in flash FV</strong> are OEM code. They go
into PCR[0].</p>
</li>
<li><p><strong>ACPI data</strong> from OEM code is important for boot. It goes into
PCR[0].</p>
</li>
<li><p>An <strong>integrated PCI card option ROM</strong> in flash FV is provided by the
OEM. It goes to PCR[0]. An <strong>external PCI card Option ROM</strong> is
third party code. It goes into PCR[2].</p>
</li>
<li><p>If <strong>a non-host component</strong> or <strong>a device firmware can only be
updated by OEM</strong> platform code, it goes into PCR[0]. If <strong>a
non-host component</strong> or <strong>a device firmware can be updated by an
entity other than the OEM</strong> platform code, it goes into PCR[2].</p>
</li>
<li><p>A <strong>CPU Microcode update</strong> can be treated as code or data. It can go
into PCR[0] or PCR[1].</p>
</li>
<li><p><strong>SMBIOS tables</strong> are OEM configuration data. They go into PCR[1].</p>
</li>
<li><p><strong>Setup variable</strong> and <strong>policy configuration</strong> are OEM
configuration data. They go into PCR[1].</p>
</li>
<li><p><strong>UEFI Boot####</strong> and <strong>BootOrder variable</strong> are OEM
configuration data. They go into PCR[1].</p>
</li>
<li><p>If <strong>a non-host component</strong> or <strong>a device firmware configuration can
only be updated by OEM</strong> platform code, it goes into PCR[1]. If
<strong>a non-host component</strong> or <strong>a device firmware configuration can be
updated by an entity other than OEM</strong> platform code, it goes into
PCR[3].</p>
</li>
<li><p>If the action is to <strong>enter an OEM provided setup utility</strong>, it goes
into PCR[1]. If the action is to <strong>enter a third party provided
setup utility</strong>, it goes into PCR[3].</p>
</li>
<li><p><strong>OS Loader</strong> is OS boot related code. It goes into PCR[4].</p>
</li>
<li><p><strong>Boot Attempt action</strong> goes into PCR[4]. The <strong>ExitBootService
action</strong> goes into PCR[5].</p>
</li>
<li><p><strong>Disk geometry, such as a GUID partition table (GPT)</strong>, is OS boot
related configuration. It goes into PCR[5].</p>
</li>
<li><p><strong>UEFI Secure Boot variables</strong>, such as the Platform Key (PK), Key
Exchange Key (KEK), image signature database (db), and image
forbidden signature database (dbx) are all related to secure boot
policy. They go into PCR[7].</p>
</li>
<li><p>If <strong>the security configuration policy</strong> is boot security sensitive,
it goes into PCR[7]. If it is NOT boot security sensitive, it goes
into PCR[1].</p>
</li>
<li><p><strong>Secure feature disabling, such as DMA protection disabling,</strong> is
security sensitive. It goes into PCR[7].</p>
</li>
<li><p><strong>Debug mode information</strong> is security sensitive. It goes into
PCR[7].</p>
</li>
</ul>
<p>Some other rules for the data that shall not be measured into PCR are as
follows:</p>
<p>1)  PCRs can only record statically configured, unchangeable data. A
    <strong>PCR cannot record data that are dynamic and changeable across the
    boot</strong>, such as system clock, fan speed, boot count, system reset
    reason, battery power, a nonce value, a pointer, etc.</p>
<p>For example:</p>
<ul>
<li><p>The firmware must measure the PE COFF image before the relocation
into different memory location.</p>
</li>
<li><p>The firmware must measure the ACPI table from flash prior to any
modification. An ACPI table patch may apply different data settings
based upon policy, such as ACPI version selection for a secondary
system description table (SSDT), or different addresses, such as a
non-volatile storage memory location for a differentiated system
description table (DSDT).</p>
</li>
<li><p>The firmware must measure partial portions of the SMBIOS table
because some SMBIOS tables may contain some automatically updated
information, such as WakeupType, Voltage, ResetCount, or
NominalSpeed.</p>
</li>
</ul>
<p>2)  A PCR can only record the class of information. A <strong>PCR cannot
    record the instance of specific information that may be used to
    unique identify a system</strong>, such as an asset tag, a serial number,
    etc.</p>
<p>For example:</p>
<ul>
<li>The firmware must measure partial portions of the SMBIOS tables
because some SMBIOS table entries may contain the instance specific
unique information, such as SerialNumber, UUID, AssetTag,
PartNumber.</li>
</ul>
<p>3)  <strong>A PCR cannot record any privacy sensitive information</strong>.</p>
<p>All of the above PCR measurements need to be recorded into an event log
which can be used to reproduce the PCR value. Besides that, the event
log may include some NO_ACTION event types. This type means that the
data are not required to be measured into PCR. The event log entry is
intended to provide additional information to the event log consumer.
For example:</p>
<ul>
<li><p><strong>Specification ID event</strong> -- It is to provide information to the
consumer regarding which version of specification is implemented.</p>
</li>
<li><p><strong>Reference Manifest event</strong> -- It is to provide NIST SP800-155
reference integrity manifest information, such as platform
manufacturer ID, reference manifest GUID, etc.</p>
</li>
<li><p><strong>Startup Locality event</strong> -- It is to record the locality from
which the TPM2_Startup command was sent in cases where the Locality
sending the TPM2_Startup command is Locality 3.</p>
</li>
</ul>
<p>Most TCG TPM related code in EDK II is located at
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg" target="_blank">SecurityPkg</a>.
The
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Pei" target="_blank">Tcg2Pei</a>
module handles the PEI phase measurement. The
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Dxe" target="_blank">Tcg2Dxe</a>
DXE driver handles the DXE phase measurement. The
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeTpm2MeasureBootLib" target="_blank">DxeTpm2MeasureBootLib</a>
library handles the PE image measurements and GPT measurement. All event
type definition can be found at
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">UefiTcgPlatform.h</a>.
Figure 3 below shows the high level flow of the modules.</p>
<p><img src="media/image3.png" alt="">{width=&quot;6.5in&quot;
height=&quot;3.4166666666666665in&quot;}</p>
<p>Figure 3: TCG Trusted Boot Flow</p>
<h3 id="pcr-0">PCR 0</h3>
<p>The SRTM&apos;s version identifier is measured by the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
<strong>MeasureCRTMVersion</strong>() function. The event type is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_S_CRTM_VERSION</a>.
EDKII uses
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdFirmwareVersionString</a>
to let a platform pass the SRTM version information. The version string
is encoded as a Unicode string with a NULL terminator.</p>
<p>The platform firmware is measured by the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
<strong>MeasureFvImage()</strong> function with firmware volume (FV) granularity. The
event type is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_PLATFORM_FIRMWARE_BLOB</a>
or
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_PLATFORM_FIRMWARE_BLOB2</a>,
based upon the
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdTcgPfpMeasurementRevision</a>.
The
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
module measures the main BIOS at <strong>MeasureMainBios</strong>() and then installs
a callback function <strong>FirmwareVolumeInfoPpiNotifyCallback</strong>() at the
memory present entrypoint <strong>PeimEntryMP</strong>(). Whenever a new FV is
installed, this callback is invoked and the new FV is measured.</p>
<p>To avoid duplicated measurements, the
<strong>FirmwareVolumeInfoPpiNotifyCallback</strong>() will carefully check the new
installed FV to ensure that the same FV will not be measured twice. It
will also ensure that the child FV will not be measured.</p>
<p>The
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/FirmwareVolumeInfoMeasurementExcluded.h" target="_blank">EFI_PEI_FIRMWARE_VOLUME_INFO_MEASUREMENT_EXCLUDED_PPI</a>
interface is designed to let a platform report to the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Pei" target="_blank">Tcg2Pei</a>
module that the installed FV is already measured. There is no need to
measure it again. This is usually done by a hardware based static root
of trust for measurement, such as Intel Authenticated Code Module (ACM)
in Intel Boot Guard technology. If the ACM has already measured the
initial FV, such as PEI FV into the TPM PCR, then a BootGuard platform
module can report this information. The
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
<strong>MeasureFvImage</strong>() service will check this PPI in order to skip the
measurement and event log report.</p>
<p>The
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/FirmwareVolumeInfoPrehashedFV.h" target="_blank">EDKII_PEI_FIRMWARE_VOLUME_INFO_PREHASHED_FV_PPI</a>
service is designed to let a platform report the hash of an FV to the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Pei" target="_blank">Tcg2Pei</a>.
This is also done by a hardware based root of trust module without
measuring the FV. The ACM in Intel Boot Guard may just use this hash to
verify the initial FV, such as PEI FV, but not measure the FV according
to the policy. Then a BootGuard platform module can report this
information. Because the hash value is stored in the Boot Guard boot
policy manifest (BPM) and it is also verified by the ACM, the hash can
be trusted.
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
<strong>MeasureFvImage</strong>() will check this PPI to skip the hash calculation
and directly measure the hash into PCR and also record the event log.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/FirmwareVolumeInfoStoredHashFv.h" target="_blank">EDKII_PEI_FIRMWARE_VOLUME_INFO_STORED_HASH_FV_PPI</a>
is also designed to let a platform report the hash of an FV, but with a
different purpose. The hash is reported to
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/FvReportPei" target="_blank">FvReportPei</a>
for FV verification, but not to the TcgPei for FV measurement. The
intent is to let
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/FvReportPei/FvReportPei.c" target="_blank">FvReportPei.c</a>
<strong>CheckStoredHashFv()</strong> verify the FV based upon the hash. The hash
value is provisioned by the OEM in the Boot Guard BPM. The ACM will NOT
verify the hash value against the corresponding FV, such as the DXE FV.
Since the hash value storage is signed and verified by the ACM it can be
trusted. Then the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/FvReportPei/FvReportPei.c" target="_blank">FvReportPei.c</a>
<strong>VerifyHashedFv()</strong> can verify the DXE FV based upon the hash
information. Once <strong>VerifyHashedFv()</strong> passes the verification, it can
install
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/FirmwareVolumeInfoPrehashedFV.h" target="_blank">EDKII_PEI_FIRMWARE_VOLUME_INFO_PREHASHED_FV_PPI</a>
to Tcg2Pei.</p>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Pei" target="_blank">Tcg2Pei</a>
is not the only module that measures data in the PEI phase. It also
produces
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/Tcg.h" target="_blank">EDKII_TCG_PPI</a>
<strong>HashLogExtendEvent</strong>() API. As such, other module can also measure the
data in the PEI phase by calling
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Include/Library/TpmMeasurementLib.h" target="_blank">TpmMeasurementLib</a>
<strong>TpmMeasureAndLogData</strong>(). The PEI instance
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/PeiTpmMeasurementLib" target="_blank">PeiTpmMeasurementLib</a>
uses the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/Tcg.h" target="_blank">EDKII_TCG_PPI</a>.
Moreover, the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/TcgEventLogRecordLib.h" target="_blank">TcgEventLogRecordLib</a>
provides more services, such as <strong>MeasureFirmwareBlob</strong>() and
<strong>MeasureHandoffTable</strong>(). The
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/TcgEventLogRecordLib/TcgEventLogRecordLib.c" target="_blank">TcgEventLogRecordLib.c</a>
can choose
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_PLATFORM_FIRMWARE_BLOB</a>
or
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_PLATFORM_FIRMWARE_BLOB2</a>,
and
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_HANDOFF_TABLES</a>
or
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_HANDOFF_TABLES2</a>
based upon
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdTcgPfpMeasurementRevision</a>.</p>
<p>Some platform firmware uses the Intel Firmware Supported Package (FSP)
binary to initialize the silicon. The FSP contains the firmware code. As
such, the FSP binary shall also be measured. The FSP-T and FSP-M are
measured by
<a href="https://github.com/tianocore/edk2/tree/master/IntelFsp2WrapperPkg/FspmWrapperPeim" target="_blank">FspmWrapperPeim</a>.
The FSP-S is measured by
<a href="https://github.com/tianocore/edk2/tree/master/IntelFsp2WrapperPkg/FspsWrapperPeim" target="_blank">FspsWrapperPeim</a>.
They call
<a href="https://github.com/tianocore/edk2/blob/master/IntelFsp2WrapperPkg/Include/Library/FspMeasurementLib.h" target="_blank">FspMeasurementLib</a>
<strong>MeasureFspFirmwareBlob</strong>() and this function calls
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/TcgEventLogRecordLib.h" target="_blank">TcgEventLogRecordLib</a>
<strong>MeasureFirmwareBlob ()</strong>. One special thing about FSP measurement is
that the FSP binary includes not only code but also configuration. A
platform may want to measure the FSP code to PCR0 and FSP static
configuration to PCR1. In order to support that,
<a href="https://github.com/tianocore/edk2/blob/master/IntelFsp2WrapperPkg/Library/BaseFspMeasurementLib/FspMeasurementLib.c" target="_blank">FspMeasurementLib.c</a>
<strong>MeasureFspFirmwareBlob</strong>() refers the <strong>PcdFspMeasurementConfig</strong> to
determine if it needs separate measurements by using
<strong>MeasureFspFirmwareBlobWithCfg</strong>().</p>
<p>All measured firmware volumes are recorded in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/MeasuredFvHob.h" target="_blank">EFI_MEASURED_FV_HOB</a>
by the Tcg2Pei.c <strong>EndofPeiSignalNotifyCallBack</strong>() service in order to
avoid duplicated measurements. If a firmware volume is NOT reported in
the PEI phase, then it needs to be measured in the DXE phase. Similar to
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Pei" target="_blank">Tcg2Pei</a>,
the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Dxe" target="_blank">Tcg2Dxe</a>
produces
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
<strong>HashLogExtendEvent</strong>() API. The DXE instance
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeTpmMeasurementLib" target="_blank">DxeTpmMeasurementLib</a>
uses the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
to let other modules measure more firmware data.</p>
<p>EDK II assumes that all OEM firmware volumes are reported in the PEI
phase. As such, the firmware volume dispatched in the DXE phase is not
measured at FV granularity, but instead the code is measured at PE image
granularity in
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeTpm2MeasureBootLib" target="_blank">DxeTpm2MeasureBootLib</a>.
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeTpm2MeasureBootLib" target="_blank">DxeTpm2MeasureBootLib</a>
is a hook to the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Security2.h" target="_blank">EFI_SECURITY2_ARCH_PROTOCOL</a>.
It is linked with
<a href="https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Universal/SecurityStubDxe" target="_blank">SecurityStubDxe</a>
and
<a href="https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Library/DxeSecurityManagementLib" target="_blank">DxeSecurityManagementLib</a>.
When the DxeCore dispatches an EFI image, it calls
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Security2.h" target="_blank">EFI_SECURITY2_ARCH_PROTOCOL</a>
<strong>FileAuthentication</strong>(). Then <strong>DxeTpm2MeasureBootHandler</strong>() will be
invoked finally. The general rule is that:</p>
<p>1) If a PE image driver or application is from an unmeasured FV, then
the PE image will be measured. A PE image driver will be measured into
PCR2 and a PE image application will be measured into PCR4.</p>
<p>2) If a PE image driver is from a measured FV, it will NOT be measured.</p>
<p>3) If a PE image application is from a measured FV, it will still be
measured to PCR4.</p>
<p>This logic is in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTpm2MeasureBootLib/DxeTpm2MeasureBootLib.c" target="_blank">DxeTpm2MeasureBootLib.c</a>
<strong>DxeTpm2MeasureBootHandler</strong>(). We will discuss more about this process
in the PCR2 section and PCR4 section, respectively.</p>
<p>If there is an additional executable binary loaded, this executable
binary shall be measured. For example, the SMM Transfer Monitor (STM)
image is measured in
<a href="https://github.com/tianocore/edk2/blob/master/UefiCpuPkg/Library/SmmCpuFeaturesLib/SmmStm.c" target="_blank">SmmStm.c</a>
<strong>LoadMonitor</strong>() with TXT_EVTYPE_STM_HASH.</p>
<p>ACPI tables should be measured before any data patches are applied. For
example, the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
measures the <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/Tpm2Acpi.h" target="_blank">TPM2
ACPI</a>
table in <strong>PublishTpm2</strong>() and <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tpm.asl" target="_blank">TPM
SSDT</a>
ACPI table in <strong>PublishAcpiTable</strong>(), before any data patches, such as
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableRev</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableLaml</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableLasa</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdActiveTpmInterfaceType</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcgPhysicalPresenceInterfaceVer</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2CurrentIrqNum</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2PossibleIrqNumBuf</a>,
etc.</p>
<p>A platform may include a non-host environment, such as the Intel
Management Engine (ME). The non-host information shall be measured with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_INFO</a>
by a platform specific module. If the non-host platform can only be
updated by Platform Firmware, then the non-host code shall be measured
with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_CODE</a>
by a platform specific module.</p>
<p>A platform may report the SRTM contents with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_S_CRTM_CONTENTS</a>.
For example, an Intel BootGuard enabled platform may report
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_S_CRTM_CONTENTS</a>
with the BootGuard ACM, Key Manifest (KM) and Boot Policy Manifest (BPM)
information.</p>
<p>EV_SEPARATOR is used to draw a line between the pre-boot environment
and entering a post-boot environment.
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
will use <strong>MeasureSeparatorEvent</strong>() to record
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_SEPARATOR</a>
with 0x00000000 for PCR0~6 in the <strong>OnReadyToBoot</strong>() function upon the
first boot attempt. EV_SEPARATOR for PCR7 is handled earlier in
<strong>MeasureSecureBootPolicy</strong>(). We will discuss this later in the PCR7
section.</p>
<p>If a system starts up with an error status, then an error
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_SEPARATOR</a>
shall be measured.
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
<strong>PeimEntryMA</strong>() detects the error and uses
<strong>MeasureSeparatorEventWithError</strong>() to record
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_SEPARATOR</a>
with 0x00000001 for PCR0~7. More details of TPM error handling will be
discussed later.</p>
<h3 id="pcr-1">PCR 1</h3>
<p>A platform usually includes multiple CPU Microcode update files and put
them all together into a microcode FV. At runtime, the CPU module will
scan them one by one and only load the one matching the current CPU. A
platform may choose to measure the whole Microcode FV or the
individually-used Microcode, such as the one from
<a href="https://github.com/tianocore/edk2/blob/master/UefiCpuPkg/Include/Guid/MicrocodePatchHob.h" target="_blank">EDKII_MICROCODE_PATCH_HOB</a>
or
<a href="https://github.com/tianocore/edk2/blob/master/UefiCpuPkg/UefiCpuPkg.dec" target="_blank">PcdCpuMicrocodePatchAddress</a>.
The current EDK II does not provide an example in the CPU module. A
platform needs to perform such measurement based upon the platform
policy.</p>
<p><a href="https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Universal/SmbiosMeasurementDxe" target="_blank">SmbiosMeasurementDxe</a>
is an example of SMBIOS table measurement. We call it an example because
the SMBIOS table measurement requires a platform specific policy to skip
the dynamic changeable information and instance-specific unique
information in the table or a field of the table. This
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Universal/SmbiosMeasurementDxe/SmbiosMeasurementDxe.c" target="_blank">SmbiosMeasurementDxe.c</a>
<strong>FilterSmbiosEntry</strong>() will skip all OEM type SMBIOS tables and zero
the dynamic changeable information and instance specific unique
information before the measurement. The policy -
<strong>mSmbiosFilterStandardTableBlackList</strong> is hardcoded in the module. Once
the SMBIOS is filtered, the <strong>MeasureSmbiosTable</strong>() function will
choose the event type
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_HANDOFF_TABLES</a>
or
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_HANDOFF_TABLES2</a>
based upon the
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdTcgPfpMeasurementRevision</a>
to measure the SMBIOS table. If a platform wants to use a different
policy, it may implement another SmbiosMeasurementDxe module and not use
this one.</p>
<p>The UEFI boot related variables, such as &quot;Boot####&quot; and &quot;BootOrder.&quot;
are measured by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>ReadAndMeasureBootVariable</strong>(). The event type is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_VARIABLE_BOOT</a>.
These variables are measured if they are present in
<strong>MeasureAllBootVariables</strong>().</p>
<p>Other Setup variables or policy configurations are OEM specific data.
They should be measured in an OEM specific module.</p>
<p>For a server platform where
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdTpmPlatformClass</a>
is TCG_PLATFORM_TYPE_SERVER, the multi-processor information
(<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/MpService.h" target="_blank">EFI_CPU_PHYSICAL_LOCATION</a>)
is measured by the module
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>MeasureHandoffTables</strong>(). The event type is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_TABLE_OF_DEVICES</a>.
Other devices are not handled in Tcg2Dxe but may be handled in an OEM
platform module.</p>
<p>If a platform has a setup utility which does not require an
unconditional reset, then the platform shall measure &quot;Entering ROM Based
Setup&quot; with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_ACTION</a>.
This can be done in the platform utility.</p>
<p>A platform may include a non-host environment, such as the Intel
Management Engine (ME). If the non-host platform can only be updated by
the Platform Firmware, then the non-host configuration should be
measured with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_CONFIG</a>
by a platform specific module.</p>
<h3 id="pcr-2">PCR 2</h3>
<p>A third party UEFI driver, such as a PCI EFI option ROM, is measured by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTpm2MeasureBootLib/DxeTpm2MeasureBootLib.c" target="_blank">DxeTpm2MeasureBootLib.c</a>
<strong>Tcg2MeasurePeImage</strong>() in <strong>DxeTpm2MeasureBootHandler</strong>(). The event
type for a UEFI boot services driver is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_BOOT_SERVICES_DRIVER</a>
and the event type for a UEFI runtime services driver is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_RUNTIME_SERVICES_DRIVER</a>.
If a UEFI driver resides in an unmeasured FV which is dispatched in the
DXE phase, it is also measured with the same policy into PCR2.</p>
<p>A platform may include a non-host environment, such as Intel Management
Engine (ME). If the non-host platform can be updated by entities other
than the Platform Firmware, then the non-host code shall be measured
with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_CODE</a>
by a platform specific module.</p>
<p>A platform may include Secure Protocol and Data Model
(<a href="https://www.dmtf.org/sites/default/files/standards/documents/DSP0274_1.1.0.pdf" target="_blank">SPDM</a>)
capable devices. The platform should use the GET_MEASUREMENT command to
retrieve the device firmware measurement and measure the immutable ROM
and mutable firmware with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_SPDM_FIRMWARE_BLOB</a>
in
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">TCG_DEVICE_SECURITY_EVENT_DATA</a>.
A prototype can be found at
<a href="https://github.com/jyao1/edk2/tree/DeviceSecurity/DeviceSecurityPkg" target="_blank">DeviceSecurityPkg</a>
<a href="https://github.com/jyao1/edk2/blob/DeviceSecurity/DeviceSecurityPkg/SpdmDeviceSecurityDxe/SpdmDeviceMeasurement.c" target="_blank">SpdmDeviceMeasurement.c</a>.
For SPDM, we will discuss the topic in the last chapter.</p>
<h3 id="pcr-3">PCR 3</h3>
<p>If the option ROM or UEFI application has a setup utility which does not
require an unconditional reset, then the platform shall measure
&quot;Entering ROM Based Setup&quot; with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_ACTION</a>.
This can be done in the utility.</p>
<p>A platform may include a non-host environment, such as the Intel
Management Engine (ME). If the non-host platform can be updated by
entities other than Platform Firmware, then the non-host configuration
should be measured with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_CONFIG</a>
by a platform specific module.</p>
<p>A platform may include SPDM capable devices. The platform should use the
GET_MEASUREMENT command to retrieve the device firmware measurement and
measure the hardware configuration and firmware configuration with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_SPDM_FIRMWARE_CONFIG</a>
in
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">TCG_DEVICE_SECURITY_EVENT_DATA</a>.</p>
<h3 id="pcr-4">PCR 4</h3>
<p>A third party UEFI application, such as a UEFI shell utility, a standard
OS loader or an OEM boot option, is measured by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTpm2MeasureBootLib/DxeTpm2MeasureBootLib.c" target="_blank">DxeTpm2MeasureBootLib.c</a>
<strong>Tcg2MeasurePeImage</strong>() in <strong>DxeTpm2MeasureBootHandler</strong>(). The event
type is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_BOOT_SERVICES_APPLICATION</a>.
If a UEFI application is an FV which is dispatched in the DXE phase, it
is also measured to PCR4 irrespective of whether the FV is measured or
unmeasured.</p>
<p>The boot attempt action is measured by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>OnReadyToBoot</strong>(). Before invoking a boot option, it measures the
action \&quot;Calling EFI Application from Boot Option\&quot;. After the boot
option returns, it measures the action
\&quot;Returning from EFI Application from Boot Option\&quot;.</p>
<h3 id="pcr-5">PCR 5</h3>
<p>When a system boots a boot option in a GUID-named partition of the disk,
the GUID partition table (GPT) disk geometry needs to be measured. It is
done by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTpm2MeasureBootLib/DxeTpm2MeasureBootLib.c" target="_blank">DxeTpm2MeasureBootLib.c</a>
<strong>Tcg2MeasureGptTable</strong>() in <strong>DxeTpm2MeasureBootHandler</strong>().</p>
<p>The ExitBootServices action is measured by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>.
If ExitBootServices succeeds, then <strong>OnExitBootServices</strong>() is invoked.
If ExitBootServices fails, then <strong>OnExitBootServicesFailed</strong>() is
invoked.</p>
<h3 id="pcr-6">PCR 6</h3>
<p>PCR6 is for OEM specific data. The open source EDK II implementation
does not have any example to measure data to PCR6.</p>
<h3 id="pcr-7">PCR 7</h3>
<p>The UEFI secure boot related variables -- &quot;SecureBoot&quot;, &quot;PK&quot;, &quot;KEK&quot;,
&quot;db&quot;, and &quot;dbx&quot; are unconditionally measured by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>ReadAndMeasureSecureVariable</strong>(). The event type is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_VARIABLE_DRIVER_CONFIG</a>.
If they are not present, a zero size UEFI variable entry will be
measured. The &quot;dbt&quot; and &quot;dbr&quot; variables are conditionally measured only
if they are present by the routine <strong>MeasureAllSecureVariables</strong>().</p>
<p>The UEFI secure boot variable update is measured in <a href="https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Universal/Variable/RuntimeDxe" target="_blank">Variable
RuntimeDxe</a>.
If any of the above secure boot related variables are updated, then
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Universal/Variable/RuntimeDxe/Measurement.c" target="_blank">Variable RuntimeDxe
Measurement.c</a>
<strong>MeasureVariable</strong>() will measure the new data with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_VARIABLE_DRIVER_CONFIG</a>.</p>
<p>When UEFI secure boot is enabled, the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeImageVerificationLib" target="_blank">DxeImageVerificationLib</a>
verifies the PE image signature based upon the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/ImageAuthentication.h" target="_blank">EFI_SIGNATURE_DATA</a>
in the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/ImageAuthentication.h" target="_blank">EFI_SIGNATURE_LIST</a>
of an image signature database. If an
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/ImageAuthentication.h" target="_blank">EFI_SIGNATURE_DATA</a>
is used to verify the image, then this
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/ImageAuthentication.h" target="_blank">EFI_SIGNATURE_DATA</a>
will be measured with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_VARIABLE_AUTHORITY</a>
in <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeImageVerificationLib/Measurement.c" target="_blank">DxeImageVerificationLib
Measurement.c</a>
<strong>MeasureVariable</strong>().</p>
<p>If a platform uses some other secure boot technology, such as Intel
BootGuard, then this secure boot policy and authority shall also be
measured into PCR7.</p>
<p>If a platform provides a firmware debugger mode, then the platform shall
measure &quot;UEFI Debug Mode&quot; string with EV_EFI_ACTION. This logic is
done at
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>MeasureSecureBootPolicy</strong>(), based upon
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdFirmwareDebuggerInitialized</a>.</p>
<p>Per Microsoft Windows requirements, a platform shall enable DMA
protection. If the DMA protection is disabled or configured to a lower
security state, then the platform shall measure the &quot;DMA Protection
Disabled&quot; string with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_ACTION</a>.
Because a platform controls the DMA protection enable/disable policy, a
platform policy driver shall measure this event.</p>
<p>If a platform uses other secure sensitive and critical configuration,
such as Intel Total Memory Encryption (TME) and System Management Mode
(SMM) protection, then the action to disable those security critical
configuration shall also be measured.</p>
<p>EV_SEPARATOR for PCR7 is handled in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>MeasureSecureBootPolicy</strong>() when the UEFI variable is ready. It is
just after <strong>MeasureAllSecureVariables</strong>(). It is earlier than the
ReadyToBoot event signal. The reason is that the PCR7
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_SEPARATOR</a>
measurement must be between secure boot policy configuration measurement
and image verification authority measurement. There might be a case
where we need to measure an UEFI image before the ReadyToBoot event. In
such an example, the authority measurement happens before the
ReadyToBoot event.</p>
<h3 id="noaction-event">NO_ACTION event</h3>
<p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">TCG_EfiSpecIDEvent</a>
is used to describe the TCG FPF specification version. It is installed
by the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Dxe" target="_blank">Tcg2Dxe</a>
<strong>SetupEventLog</strong>() function, based upon
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdTcgPfpMeasurementRevision</a>.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">TCG_Sp800_155_PlatformId_Event2</a>
is usually installed by a platform TCG PEI or DXE module, such as
<a href="https://github.com/jyao1/edk2/tree/feature_tpm_emulator/EmulatorPkg/Tpm2/Platform800155EventPei" target="_blank">Platform800155EventPei</a>
or
<a href="https://github.com/jyao1/edk2/tree/feature_tpm_emulator/EmulatorPkg/Tpm2/Platform800155EventDxe" target="_blank">Platform800155EventDxe</a>.
A platform TCG PEIM may use
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TcgEventHob.h" target="_blank">EFI_TCG_800_155_PLATFORM_ID_EVENT_HOB</a>
for this event and it will be converted by the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>SetupEventLog</strong>() function.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">TCG_EfiStartupLocalityEvent</a>
is usually installed by a platform module in the PEI phase, such as a
BootGuard related PEIM or
<a href="https://github.com/jyao1/edk2/tree/feature_tpm_emulator/EmulatorPkg/Tpm2/StartupLocalityEventPei" target="_blank">StartupLocalityEventPei</a>.
It shall use
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TcgEventHob.h" target="_blank">EFI_TPM2_STARTUP_LOCALITY_HOB</a>
for this event and it will be converted by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>SetupEventLog</strong>() function. This NO_ACTION event is added when a
BootGuard ACM starts up the TPM device.</p>
<h3 id="event-log">Event Log</h3>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Pei" target="_blank">Tcg2Pei</a>
records the event log to a
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TcgEventHob.h" target="_blank">EFI_TCG_EVENT2_HOB</a>.
The HOB will be consumed by
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Dxe" target="_blank">Tcg2Dxe</a>
and converted into a formal TCG event log.</p>
<p>There are two ways to expose a TCG event log. The first way is via the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
<strong>GetEventLog</strong>() API. This protocol is installed by the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Dxe" target="_blank">Tcg2Dxe</a>
module directly. Care must be taken that even after the OS calls
<strong>GetEventLog</strong>() API, a platform firmware module may add additional
event log entries, such as
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_ACTION</a>
event &quot;Exit Boot Services Invocation&quot;. Once the <strong>GetEventLog</strong>() API is
called, the additional event log is added to
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_FINAL_EVENTS_TABLE</a>.
This table is installed as a UEFI configuration table with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_FINAL_EVENTS_TABLE_GUID</a>.</p>
<p>The second way the expose the event log is via a <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/Tpm2Acpi.h" target="_blank">TPM2
ACPI</a>
table as an optional feature. The TCG event log will be produced via
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableLaml</a>
and
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableLasa</a>
by
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Dxe" target="_blank">Tcg2Dxe</a>.
Then
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
consumes those two PCD and installs this ACPI table for the operating
system.</p>
<h3 id="hardware-root-of-trust">Hardware Root of Trust</h3>
<p>A platform may choose to use a dedicated hardware root of trust to
verify the platform firmware, such as Intel Boot Guard Technology or AMD
Platform Security Processor (PSP). If this mode is chosen, then there
should be dedicated event logs for the related component.</p>
<p>For example, if Intel Boot Guard measured boot is enabled, then the
platform shall record
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">TCG_EfiStartupLocalityEvent</a>
and may report a
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_S_CRTM_CONTENTS</a>
event in PCR[0]. If Intel Boot Guard verified boot is enabled, then
the secure boot policy and authority shall also be reported in PCR[7].</p>
<h3 id="trusted-boot-chain----putting-it-all-together">Trusted Boot Chain -- Putting it all together</h3>
<p>Figure 4 shows a complete trusted boot chain that commences from a
hardware root of trust module.</p>
<p><img src="media/image4.png" alt="">{width=&quot;6.196969597550306in&quot;
height=&quot;2.22455271216098in&quot;}</p>
<p>Figure 4: TCG Trusted Boot Flow</p>
<p>For test purposes, we have a UEFI shell tool
<a href="https://github.com/jyao1/EdkiiShellTool/tree/master/EdkiiShellToolPkg/Tcg2DumpLog" target="_blank">Tcg2DumpLog</a>
to display the TCG event log. Because the event log records every step
of the PCR extend, we can reproduce the PCR values by using the digests
in the TCG event log.</p>
<p>If a developer does not have hardware, they can use a TPM2 simulator,
such as <a href="https://github.com/microsoft/ms-tpm-20-ref" target="_blank">Microsoft TPM2
simulator</a>. Currently, <a href="https://github.com/jyao1/edk2/tree/feature_tpm_emulator/EmulatorPkg/Tpm2" target="_blank">EDK
II
Tpm2Emulator</a>
can be used to communicate with the <a href="https://github.com/microsoft/ms-tpm-20-ref" target="_blank">Microsoft TPM2
simulator</a> via a socket
interface on ports 2321 and 2322. Then the developer can use the
<a href="https://github.com/jyao1/EdkiiShellTool/tree/master/EdkiiShellToolPkg/Tcg2DumpLog" target="_blank">Tcg2DumpLog</a>
to dump the TCG event log in the EDK II emulator environment.</p>
<p>The whole TPM software stack (TSS) is out of scope of this document.
There is prototype
<a href="https://github.com/flihp/edk2/tree/tpm2-tss/Tpm2TssPkg" target="_blank">Tpm2TssPkg</a> for
reference only.</p>
<h3 id="remote-attestation">Remote Attestation</h3>
<p>Remote attestation is a client/server process that helps you retrieve a
quote from the TPM. A quote is process that provides a list of the
current PCR values that are signed by the TPM.</p>
<p>A full remote attestation process includes two major steps:</p>
<ul>
<li><p>The server verifies the client TPM device.</p>
</li>
<li><p>The server verifies the TCG event log from the client.</p>
</li>
</ul>
<p>Figure 5 shows the TPM device verification flow.</p>
<p>1)  Every TPM includes an Endorsement Key (EK) signed by a root EK which
    belongs to the TPM vendor. It also includes an Attestation Key (AK).
    The client sends the TPM EK and AK to a server.</p>
<p>2)  The server verifies the EK based upon the TPM vendor root CA cert.
    The server generates a random secret and encrypts the secret and AK
    with the EK public key to be used as a challenge. Then the server
    sends the challenge to client.</p>
<p>3)  The client decrypts the secret with the EK private key and check the
    AK. Then the client sends the secret back to server.</p>
<p>4)  Now the server knows the client has a genuine TPM.</p>
<p>Figure 6 shows the event log verification.</p>
<p>1)  The server asks the client platform for a quote.</p>
<p>2)  The client platform asks the TPM to sign the PCR list with the AK
    private key as a quote. Then the client sends the quote to the
    server.</p>
<p>3)  The server verifies the signature of the quote with the AK public
    key. Now the server knows the PCR list is genuine. If the
    verification succeeds, then the server sends a request to get an
    event log.</p>
<p>4)  The client platform sends the event log directly to the server.</p>
<p>5)  The server replays the event log to reproduce the PCR values. If
    they are same, then the server knows the TCG event log is genuine.</p>
<p><img src="media/image5.jpeg" alt="">{width=&quot;6.391025809273841in&quot;
height=&quot;4.260684601924759in&quot;}</p>
<p>Figure 5: Remote Attestation -- TPM Device Verification (Source:
<a href="https://developer.ibm.com/articles/trusted-boot-openpower/" target="_blank">OpenPower
TrustBoot</a>)</p>
<p><img src="media/image6.jpeg" alt="">{width=&quot;6.514963910761155in&quot;
height=&quot;3.8846161417322835in&quot;}</p>
<p>Figure 6: Remote Attestation -- Event Log Verification (Source:
<a href="https://developer.ibm.com/articles/trusted-boot-openpower/" target="_blank">OpenPower
TrustBoot</a>)</p>
<p>Once the verifier in the server gets the event log, the verifier can
compare it with the reference integrity measurement (RIM) based upon a
predefine policy.</p>
<p>Figure 7 shows the final RIM validation process.</p>
<p><img src="media/image7.png" alt="">{width=&quot;6.5in&quot;
height=&quot;3.1104166666666666in&quot;}</p>
<p>Figure 7. RIM Validation (source: <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_FIM_v1_r40_02dec2020.pdf" target="_blank">TCG
FIM</a>)</p>
<p>For test purposes, we created a sample
<a href="https://github.com/jyao1/FSP/tree/FspAttestation/Tools/ManifestTools" target="_blank">FspManifestTool</a>.
It can be used to generate a
<a href="https://csrc.nist.gov/publications/detail/nistir/8060/final" target="_blank">SWID</a> or
<a href="https://datatracker.ietf.org/doc/draft-ietf-sacm-coswid/" target="_blank">CoSWID</a> tag
for an FSP binary as the reference integrity manifest (RIM). The FSP RIM
can be used to verify the FSP binary based upon the TCG event log.</p>
<h2 id="tpm-device-startup">TPM Device Startup</h2>
<p>The platform firmware needs to send a TPM Startup command to the TPM
before measuring any data into a PCR register. TPM specification defines
three shutdown/startup sequences:</p>
<ul>
<li><strong>TPM Reset</strong> -- Tpm2Startup(CLEAR) after Tpm2Shutdown(CLEAR) or no
shutdown command is sent.</li>
</ul>
<p>All those values that are specified as having a default initialization
state go back to their default initialization state. Persistent values
that have no default initialization state are not changed.</p>
<ul>
<li><strong>TPM Restart</strong> -- Tpm2Startup(CLEAR) after Tpm2Shutdown(STATE).</li>
</ul>
<p>This preserves much of the previous state of the TPM, except the PCRs
and the controls associated with the Platform hierarchy are all returned
to their default initialization state.</p>
<ul>
<li><strong>TPM Resume</strong> -- Tpm2Startup(STATE) after Tpm2Shutdown(STATE).</li>
</ul>
<p>This preserves the previous state of the TPM, including the static Root
of Trust for Measurement (S-RTM) PCR and the platform controls other
than the PlatformHierarchyEnable.</p>
<p>Tpm2Startup(STATE) after Tpm2Shutdown(CLEAR) or no shutdown is an
invalid sequence and will fail.</p>
<p>TPM startup is done in the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
<strong>PeimEntryMA()</strong> function. <strong>Tpm2Startup</strong>(TPM_SU_CLEAR) will be used
if the system is in normal boot path, and
<strong>Tpm2Startup</strong>(TPM_SU_STATE) will be used if the system is in the S3
resume path. The issuing of the Startup command is controlled by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2InitializationPolicy</a>
because other modules may use the TPM and send a Startup command before
Tcg2Pei. One example is TPM1.2/TPM2.0 detection in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Config/Tcg2ConfigPeim.c" target="_blank">Tpm2ConfigPeim.c</a>
<strong>DetectTpmDevice</strong>(). The other example is TPM device startup in an
Intel BootGuard ACM. If the TPM is started by a BootGuard ACM, then the
platform needs to add a
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">TCG_EfiStartupLocalityEvent</a>
to indicate that the startup locality is 3.</p>
<p>The platform firmware may send a TPM Shutdown command if a reset happens
in the pre-OS environment.
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
registers a <strong>ShutdownTpmOnReset</strong>() callback function on the system
reset event. <strong>Tpm2Shutdown</strong>(TPM_SU_CLEAR) will be used to shut down
the TPM device.</p>
<p>The TPM measurements happen in both a normal boot path and a S4 resume.
In an S3 resume, there is no need to measure the firmware components
because the TPM state is restored in the S3 resume path. The assumption
is that the OS shall issue a <strong>Tpm2Shutdown</strong>(TPM_SU_STATE) to save
the TPM state. Then platform firmware uses
<strong>Tpm2Startup</strong>(TPM_SU_STATE) to restore the state.</p>
<p>If the OS does not send <strong>Tpm2Shutdown</strong>() or sends
<strong>TpmShutdown</strong>(TPM_SU_CLEAR), then the
<strong>Tpm2Startup</strong>(TPM_SU_STATE) will fail. Then
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
will start error handling and use <strong>Tpm2Startup</strong>(TPM_SU_CLEAR) to
start up TPM again. If the TPM can be started, then
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
will call <strong>MeasureSeparatorEventWithError</strong>() to record EV_SEPARATOR
with 0x00000001 for PCR0~7. This action is required to cap the PCR&apos;s to
an invalid state in order to resist the PCR forgery attack.</p>
<h3 id="tpm-device-selection">TPM Device Selection</h3>
<p>A platform TPM can be implemented in different ways, such as a discrete
TPM2.0 (dTPM) with either a Serial Peripheral Interface (SPI) or
Inter-Integrated Circuit (I2C) bus, a firmware TPM2.0 (fTPM), or even a
legacy TPM1.2 device. A platform needs to select the TPM device at build
time or at runtime.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TpmInstance.h" target="_blank">TPM_DEVICE_SELECTED_GUID</a>
PPI is an interface that indicates that the platform has selected the
TPM device.
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Pei" target="_blank">Tcg2Pei</a>
can run to start the TPM. If Tcg2Pei starts the TPM successfully, it
will install
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/TpmInitialized.h" target="_blank">PEI_TPM_INITIALIZED_PPI</a>
to tell other module that the TPM is initialized and ready to use. No
matter whether TPM startup succeeds or fails, Tcg2Pei always installs
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/TpmInitialized.h" target="_blank">PEI_TPM_INITIALIZATION_DONE_PPI</a>
to tell other modules that the TPM initialization process is done. Other
modules can locate
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/TpmInitialized.h" target="_blank">PEI_TPM_INITIALIZED_PPI</a>
to know if it has succeeded or failed.</p>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Config" target="_blank">Tcg2Config</a>
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Config/TpmDetection.c" target="_blank">TpmDetection.c</a>
provides a sample implementation to detect a TPM1.2 or TPM2.0. Besides
installing
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TpmInstance.h" target="_blank">TPM_DEVICE_SELECTED_GUID</a>
PPI, it also sets
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TpmInstance.h" target="_blank">TPM_DEVICE_INTERFACE_TPM20_DTPM</a>
to
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpmInstanceGuid</a>,
which is checked by
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
to ensure that only a discrete TPM 2.0 can be supported by
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>.</p>
<p>A platform may also install the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TpmInstance.h" target="_blank">TPM_DEVICE_SELECTED_GUID</a>
PPI and set
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpmInstanceGuid</a>
directly if the configuration is fixed.</p>
<h3 id="tpm-device-interface">TPM Device Interface</h3>
<p>The main TPM specification defines the TPM commands. In EDK II, the TPM
commands are defined in
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/Tpm20.h" target="_blank">Tpm20.h</a>.</p>
<p>A TPM hardware device may support the First-In-First-Out (FIFO)
interface or Command Response Buffer (CRB). The FIFO interface defines a
set of data input/output IO registers for the TPM commands. The CRB
interface defines a chunk of DMA memory buffer for the TPM commands. In
EDK II, both the TPM FIFO and CRB interfaces are described in
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/TpmPtp.h" target="_blank">TpmPtp.h</a>,</p>
<p>EDKII TCG drivers are TPM interface agnostic. They just send commands
via
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tpm2CommandLib.h" target="_blank">Tpm2CommandLib</a>.
The
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/Tpm2CommandLib" target="_blank">Tpm2CommandLib</a>
implementation is also TPM interface agnostic and sends command to
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tpm2DeviceLib.h" target="_blank">Tpm2DeviceLib</a>.
The Tpm2DeviceLib abstracts how to send a TPM command. For example,
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/Tpm2DeviceLibTcg2" target="_blank">Tpm2DeviceLibTcg2</a>
is the instance to send a TPM command via
EFI_TCG2_PROTOCOL.SubmitCommand().
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/Tpm2DeviceLibDTpm" target="_blank">Tpm2DeviceLibDTpm</a>
is the instance to send a TPM command to the hardware via FIFO or CRB.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/Tpm2DeviceLibDTpm/Tpm2DeviceLibDTpm.c" target="_blank">Tpm2DeviceLibDTpm.c</a>
detects the TPM device interface type in <strong>Tpm2GetPtpInterface</strong>(). It
checks the FIFO and CRB register to know the device interface. Then this
function sets the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdActiveTpmInterfaceType</a>.
Then</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/Tpm2DeviceLibDTpm/Tpm2DeviceLibDTpm.c" target="_blank">Tpm2DeviceLibDTpm.c</a>
detects the TPM device interface type in <strong>Tpm2GetPtpInterface</strong>(). It
checks the FIFO and CRB register to know the device interface. Then this
function sets the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdActiveTpmInterfaceType</a>.</p>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/Tpm2DeviceLibDTpm" target="_blank">Tpm2DeviceLibDTpm</a>
sends a TPM command in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/Tpm2DeviceLibDTpm/Tpm2Ptp.c" target="_blank">Tpm2Ptp.c</a>
<strong>DTpm2SubmitCommand</strong>(). It checks
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdActiveTpmInterfaceType</a>
and calls
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/Tpm2DeviceLibDTpm/Tpm2Tis.c" target="_blank">Tpm2Tis.c</a>
<strong>Tpm2TisTpmCommand</strong>() for the FIFO interface or
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/Tpm2DeviceLibDTpm/Tpm2Ptp.c" target="_blank">Tpm2Ptp.c</a>
<strong>PtpCrbTpmCommand</strong>() for the CRB interface.</p>
<p>Figure 8 shows the TCG trusted boot component in EDK II.</p>
<p><img src="media/image8.png" alt="">{width=&quot;6.492361111111111in&quot;
height=&quot;4.666666666666667in&quot;}</p>
<p>Figure 8: TCG Trusted Boot Component in EDK II</p>
<h3 id="error-handling">Error Handling</h3>
<p>TPM errors may happen at any time. According to the TCG specification,
capping PCR is always required. If the PCR cannot be capped, the
platform SHOULD take any necessary action to notify the host platform&apos;s
administrator, user, and operator of this situation and transition to a
&quot;fail-safe&quot; mode by performing one of these actions:</p>
<ul>
<li><p>Make the TPM interface inaccessible via hardware for the remainder
of the power cycle</p>
</li>
<li><p>Reboot the Host Platform</p>
</li>
<li><p>Disable the Host Platform</p>
</li>
<li><p>Perform a vendor-specific action that is equivalent to one of the
options above.</p>
</li>
</ul>
<p>When a TPM returns an error,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
will create a
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TcgEventHob.h" target="_blank">EFI_TPM_ERROR</a>
HOB and report the error status code via <strong>REPORT_STATUS_CODE</strong>() with
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdStatusCodeSubClassTpmDevice</a>.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
will detect the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TcgEventHob.h" target="_blank">EFI_TPM_ERROR</a>
HOB and not install
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
if there is a TPM error. If the TPM error happens after the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
installation,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
will set the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_BOOT_SERVICE_CAPABILITY.TPMPresentFlag</a>
to be FALSE. At this point the OS will know the TPM is absent. Similar
to
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
also reports the error status code via <strong>REPORT_STATUS_CODE</strong>().</p>
<p>A platform module may register a ReportStatusCode callback handler to
process the TPM error, such as reset system, or disable the TPM
hardware.</p>
<h2 id="tcg-physical-presence">TCG Physical Presence</h2>
<p>TCG Physical Presence (PP) interface is a way to let an OS send a
request to configure the TPM device, such as Clear, SetPCRBanks,
ChangeEPS, Enable, Disable, DisableEndorsementEnableStorageHierarchy.
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/TcgPhysicalPresence.h" target="_blank">TcgPhysicalPresence.h</a>
lists all TCG PP operation defined by the TCG PP specification.</p>
<p>EDK II defines a
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tcg2PhysicalPresenceLib.h" target="_blank">Tcg2PhysicalPresenceLib</a>
to abstract the TCG PP functions. It has three instances -
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/PeiTcg2PhysicalPresenceLib" target="_blank">PeiTcg2PhysicalPresenceLib</a>,
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeTcg2PhysicalPresenceLib" target="_blank">DxeTcg2PhysicalPresenceLib</a>,
and
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/SmmTcg2PhysicalPresenceLib" target="_blank">SmmTcg2PhysicalPresenceLib</a>.
The TCG PP related ACPI code is at
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tpm.asl" target="_blank">Tpm.asl</a>
of the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
driver.</p>
<p>During boot,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tcg2Smm.c" target="_blank">Tcg2Smm.c</a>
<strong>PublishAcpiTable</strong>() allocates the non-volatile storage ACPI OpRegion</p>
<ul>
<li>mTcgNvs for
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tpm.asl" target="_blank">ASL</a>/SMM
communication. At runtime, the OS locates the TPM device - <strong>Name</strong>(CID,
\&quot;MSFT0101\&quot;) and calls the <strong>_DSM</strong>() method. The first parameter is a
UUID. The value (3dddfaa6-361b-4eb4-a424-8d10089d1653) means the
function call is TCG PP request. Finally, the <strong>TPPI</strong>() method fills
the parameter in the <strong>OperationRegion</strong>(TNVS) and triggers the SMI -
<strong>Store</strong>(PPIN, IOPN).</li>
</ul>
<p>Then
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tcg2Smm.c" target="_blank">Tcg2Smm.c</a>
<strong>PhysicalPresenceCallback</strong>() will be triggered to handle such a PP
request. It checks the parameters and calls the corresponding function
in
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/SmmTcg2PhysicalPresenceLib" target="_blank">SmmTcg2PhysicalPresenceLib</a>.
EDK II defines two PP variables:</p>
<ul>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresence</a>
variable. It is a read/write variable because anyone can send the PP
request. The data structure is
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">EFI_TCG2_PHYSICAL_PRESENCE</a>.
This variable is to record the TCG PP request, request parameter,
and finally, the response result.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresenceFlags</a>
variable. It is a read-only variable to prevent modification from
malicious software. The data structure is
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">EFI_TCG2_PHYSICAL_PRESENCE_FLAGS</a>.
This variable is to record the TCG management flags. The flags are
defined in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tcg2PhysicalPresenceLib.h" target="_blank">Tcg2PhysicalPresenceLib</a>,
such as TCG2_BIOS_TPM_MANAGEMENT_FLAG_xxx,
TCG2_BIOS_INFORMATION_FLAG_xxx,
TCG2_BIOS_STORAGE_MANAGEMENT_FLAG_xxx.</p>
</li>
</ul>
<p>If the OS submits a TPM configuration change request, then this request
is saved in the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresence</a>
variable.</p>
<p>Upon the next boot, a PlatformBds module, such as
<a href="https://github.com/tianocore/edk2-platforms/blob/master/Platform/Intel/BoardModulePkg/Library/BoardBdsHookLib/BoardBdsHookLib.c" target="_blank">BoardBdsHookLib</a>,
needs to process the TCG PP request. <strong>ProcessTcgPp</strong>() needs to check
<strong>Tcg2PhysicalPresenceLibNeedUserConfirm</strong>(), connect the platform
specific trusted console if user confirmation is required, and then call
<strong>Tcg2PhysicalPresenceLibProcessRequest</strong>().</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTcg2PhysicalPresenceLib/DxeTcg2PhysicalPresenceLib.c" target="_blank">DxeTcg2PhysicalPresenceLib.c</a>
implements the <strong>Tcg2PhysicalPresenceLibProcessRequest</strong>(). It calls
<strong>VariableLockProtocol</strong>-&gt;<strong>RequestToLock</strong>() to lock the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresenceFlags</a>
variable, reads
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresence</a>
variable, and then calls <strong>Tcg2ExecutePendingTpmRequest</strong>() to process
the request. If user confirmation is required, then
<strong>Tcg2UserConfirm</strong>() is called. Once the configuration is confirmed,
the TPM is configured in <strong>Tcg2ExecutePhysicalPresence</strong>(), such as
Clear, SetPCRBanks, ChangeEPS, LogAllDigests. After configuration,
<strong>Tcg2ExecutePendingTpmRequest</strong>() then records the new configuration in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresenceFlags</a>
variable and the PP result in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresence</a>
variable. Finally, this function will reset the system in order to make
the new settings take effect.</p>
<p>Please be aware that <strong>Tcg2PhysicalPresenceLibProcessRequest</strong>() shall
be called before EndOfDxe event because the read-only
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresenceFlags</a>
variable can only be updated before EndOfDxe.</p>
<p>Once the PP request is processed, the OS may use ACPI <strong>_DSM</strong>() method
again to get the result.
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tcg2Smm.c" target="_blank">Tcg2Smm.c</a>
<strong>PhysicalPresenceCallback</strong>() will return the result from
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresence</a>
variable.</p>
<h3 id="tpm-bank-selection">TPM Bank Selection</h3>
<p>A TPM device may have multiple banks of PCRs. A PCR bank is a collection
of PCRs that are extended with the same hash algorithm. PCR banks are
identified by the hash algorithm used to extend the PCR in that bank.</p>
<p>The PP operation
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/TcgPhysicalPresence.h" target="_blank">TCG2_PHYSICAL_PRESENCE_SET_PCR_BANKS</a>
can be used to configure the active PCR banks.</p>
<p>Besides the PP request, the OS may use
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
for TPM active bank management as well. <strong>GetActivePcrBanks</strong>() returns
the current active banks. <strong>SetActivePcrBanks</strong>() is used to set the new
PCR banks request. It does not take effect immediately, but just saves a
request. The new PCR bank setting request will be processed in the next
boot. <strong>GetResultOfSetActivePcrBanks</strong>() is used to get the new PCR
banks setting result.</p>
<p>EDK II
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
just uses the same
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresence</a>
variable for the implementation. Later
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTcg2PhysicalPresenceLib/DxeTcg2PhysicalPresenceLib.c" target="_blank">DxeTcg2PhysicalPresenceLib.c</a>
calls <strong>Tcg2ExecutePhysicalPresence</strong>() and then
<strong>Tpm2GetCapabilitySupportedAndActivePcrs</strong>() in order to get the
current supported PCR banks and compares them. If one of the new PCR
banks is not supported, then the request will be rejected. Otherwise,
this function calls <strong>Tpm2PcrAllocateBanks</strong>() to set the new banks and
then reset the system.</p>
<p>Care must be taken that the final active PCR banks value is based upon
multiple criteria:</p>
<p>1)  TPM supported PCR banks - It can be retrieved from
    <strong>Tpm2GetCapabilitySupportedAndActivePcrs</strong>(&amp;TpmHashAlgorithmBitmap).</p>
<p>2)  TPM end user desired current active PCR banks -- It can also be
    retrieved from
    <strong>Tpm2GetCapabilitySupportedAndActivePcrs</strong>(&amp;TpmActivePcrBanks).</p>
<p>3)  The OEM configuration supported active PCR banks -- the OEM may
    select a subset of hash algorithms. It is recorded in
    <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>.</p>
<p>4)  The platform firmware software capability -- the OEM may select a
    subset of hash algorithms. It is recorded in
    <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcg2HashAlgorithmBitmap</a>.</p>
<p>The final effective PCR banks is a subset of all of them. For example,
take a TPM that supports SHA256|SHA384|SM3_256. The end user desired
active PCR bank is SHA256. The supported active PCR banks is
SHA256|SHA384. The platform firmware software capability is
SHA256|SHA384. Then the final effective PCR banks is SHA256 only.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
<strong>SyncPcrAllocationsAndPcrMask</strong>() function is used to synchronize the
settings. This includes ensuring that the TPM has appropriate hardware
capability (TpmHashAlgorithmBitmap), the current active PCR banks
(TpmActivePcrBanks), and the supported active PCR banks
(<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>).
These all need to be in agreement.</p>
<ul>
<li><p>If there is a bank in TpmActivePcrBanks that is not described in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>,
then it means that the OEM does not want to enable this bank.
<strong>SyncPcrAllocationsAndPcrMask</strong>() will call
<strong>Tpm2PcrAllocateBanks</strong>() to remove the bank from the active PCR
banks and reset the system.</p>
</li>
<li><p>If there is a bank in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>
but not supported in the TpmHashAlgorithmBitmap, that means the OEM
configured an invalid bank. <strong>SyncPcrAllocationsAndPcrMask</strong>() will
update
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>.</p>
</li>
</ul>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>
serves as an indicator of the supported active PCR banks. It will be
used to guide
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcg2HashAlgorithmBitmap</a>
generation and during the hash algorithm registration in
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashLibBaseCryptoRouter" target="_blank">HashLibBaseCryptoRouter</a>.
A platform may register multiple hash algorithms, such as
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashInstanceLibSha256" target="_blank">HashInstanceLibSha256</a>,
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashInstanceLibSha384" target="_blank">HashInstanceLibSha384</a>,
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashInstanceLibSha512" target="_blank">HashInstanceLibSha512</a>
and
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashInstanceLibSm3" target="_blank">HashInstanceLibSm3</a>.
If a hash algorithm is not indicated in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>,
this hash algorithm will not be registered successfully. The final
registered hash algorithms value is a subset of
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>
and is recorded in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcg2HashAlgorithmBitmap</a>.</p>
<p>Figure 9 shows the TPM bank selection in EDK II.</p>
<p><img src="media/image9.png" alt="">{width=&quot;6.492361111111111in&quot;
height=&quot;3.7805555555555554in&quot;}</p>
<p>Figure 9: TPM Bank Selection in EDK II</p>
<p>In brief, we have below result:</p>
<ul>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>
(supported active PCR banks) must be a subset of
TpmHashAlgorithmBitmap (TPM capability).</p>
</li>
<li><p>TpmActivePcrBanks (end user desired active PCR banks) must be a
subset of
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcg2HashAlgorithmBitmap</a>
(platform firmware capability) must be a subset of
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>.</p>
</li>
</ul>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcg2HashAlgorithmBitmap</a>
serves as an indicator of the firmware hash algorithm capability.
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
needs to report the capability to the OS with the following values:</p>
<ul>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_BOOT_SERVICE_CAPABILITY.HashAlgorithmBitmap</a>
shall be the (TpmHashAlgorithmBitmap &amp;
PcdGet32 (PcdTcg2HashAlgorithmBitmap))</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_BOOT_SERVICE_CAPABILITY.ActivePcrBanks</a>
shall be the (TpmActivePcrBanks &amp;
PcdGet32 (PcdTcg2HashAlgorithmBitmap))</p>
</li>
</ul>
<p>In the above example, we have following configuration:</p>
<ul>
<li><p>TpmHashAlgorithmBitmap is SHA256|SHA384|SM3_256.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>
is SHA256|SHA384.</p>
</li>
<li><p>TpmActivePcrBanks is SHA256.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcg2HashAlgorithmBitmap</a>
is SHA256|SHA384.</p>
</li>
</ul>
<p>The final report is:</p>
<ul>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_BOOT_SERVICE_CAPABILITY.HashAlgorithmBitmap</a>
is SHA256|SHA384.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_BOOT_SERVICE_CAPABILITY.ActivePcrBanks</a>
is SHA256.</p>
</li>
</ul>
<p>Then the end user may have chance to enable SHA384 for the platform.</p>
<h3 id="tpm-hierarchy-management">TPM Hierarchy Management</h3>
<p>TPM has three hierarchies -- platform hierarchy, storage hierarchy and
endorsement hierarchy.</p>
<p>The platform hierarchy is managed by the platform firmware. Before
booting to the OS, the platform firmware shall randomize the platform
hierarchy auth value in order to prevent another entity from accessing
the platform hierarchy.</p>
<p>A sample implementation of this randomization can be found in the
<a href="https://github.com/tianocore/edk2-platforms/tree/master/Platform/Intel/MinPlatformPkg/Tcg" target="_blank">Tcg2Platform</a>
module in EDK II platform repository. In a normal boot path,
<a href="https://github.com/tianocore/edk2-platforms/blob/master/Platform/Intel/MinPlatformPkg/Tcg/Tcg2PlatformDxe/Tcg2PlatformDxe.c" target="_blank">Tcg2PlatformDxe.c</a>
calls <strong>ConfigureTpmPlatformHierarchy</strong>() in
<a href="https://github.com/tianocore/edk2-platforms/blob/master/Platform/Intel/MinPlatformPkg/Tcg/Library/TpmPlatformHierarchyLib/TpmPlatformHierarchyLib.c" target="_blank">TpmPlatformHierarchyLib.c</a>
to randomize the platform auth value in EndOfDxe event. Once the
<strong>Tpm2HierarchyChangeAuth</strong>() command is sent to the TPM, no one else
can use the platform hierarchy without knowing the random number. In the
S3 resume path, there is no need to randomize the platform auth value
again if the Tcg2Pei resumes TPM successfully. However, if a TPM resume
fails and Tcg2Pei needs to restart the TPM, then
<a href="https://github.com/tianocore/edk2-platforms/blob/master/Platform/Intel/MinPlatformPkg/Tcg/Tcg2PlatformPei/Tcg2PlatformPei.c" target="_blank">Tcg2PlatformPei.c</a>
<strong>RandomizePlatformAuth</strong>() is called to randomize the platform auth
value in the EndOfPei event <strong>PlatformInitEndOfPei</strong>() before the
platform firmware resumes to the OS.</p>
<p>The OS manages the storage hierarchy, which is independent of the
platform hierarchy. The OS may ask the platform auth to clear the TPM
via TCG PP operation
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/TcgPhysicalPresence.h" target="_blank">TCG2_PHYSICAL_PRESENCE_CLEAR</a>.
Later
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTcg2PhysicalPresenceLib/DxeTcg2PhysicalPresenceLib.c" target="_blank">DxeTcg2PhysicalPresenceLib.c</a>
calls <strong>Tcg2ExecutePhysicalPresence</strong>() then <strong>Tpm2CommandClear</strong>() to
clear the TPM.</p>
<p>Other PP operations such as
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/TcgPhysicalPresence.h" target="_blank">TCG2_PHYSICAL_PRESENCE_ENABLE</a>,
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/TcgPhysicalPresence.h" target="_blank">TCG2_PHYSICAL_PRESENCE_DISABLE</a>,
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/TcgPhysicalPresence.h" target="_blank">TCG2_PHYSICAL_PRESENCE_DISABLE_ENDORSEMENT_ENABLE_STORAGE_HIERARCHY</a>
can be used to enable or disable the storage hierarchy or the
endorsement hierarchy. These are optional features. If they are
implemented, then Tcg2Pei needs to call the
<strong>Tcg2PhysicalPresenceLibGetManagementFlags</strong>() function from
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/PeiTcg2PhysicalPresenceLib" target="_blank">PeiTcg2PhysicalPresenceLib</a>,
check TCG2_BIOS_INFORMATION_FLAG_HIERARCHY_CONTROL_xxx flags in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tcg2PhysicalPresenceLib.h" target="_blank">Tcg2PhysicalPresenceLib</a>
and send <strong>Tpm2HierarchyControl</strong>() command to enable or disable the
hierarchy.</p>
<p>TCG PP Interface not only controls TPM configuration, but it also
controls the TCG storage configuration, such as BlockSid. We will
discuss that in TCG storage section.</p>
<p>TCG PP interface also supports vendor specific extensions. EDK II
defines
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tcg2PpVendorLib.h" target="_blank">Tcg2PpVendorLib</a>
to serve that purpose.</p>
<p>Figure 10 shows TCG PP component in EDK II.</p>
<p><img src="media/image10.png" alt="">{width=&quot;6.5in&quot;
height=&quot;4.530555555555556in&quot;}</p>
<p>Figure 10: TCG PP Component in EDK II</p>
<h2 id="tcg-memory-overwrite-mor">TCG Memory Overwrite (MOR)</h2>
<p>The memory overwrite (MOR) feature is to mitigate the platform reset
attack. It is not related to the TPM hardware but is a pure software
feature.</p>
<p>The TCG Platform Reset Mitigation specification defines two UEFI
variables:</p>
<ul>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/MemoryOverwriteControl.h" target="_blank">MemoryOverwriteRequestControl</a>
variable (MOR variable). It is a read/write variable. This variable
is to record the TCG MOR request state.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/MemoryOverwriteRequestControlLock.h" target="_blank">MemoryOverwriteRequestControlLock</a>
variable (MorLock variable). It is lockable in some situations to
prevent modification from malicious software. This variable is to
control the lock state of
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/MemoryOverwriteControl.h" target="_blank">MemoryOverwriteRequestControl</a>
variable and itself. It can be accessed with a UEFI variable service
-- SetVariable()/GetVariable(). But it is not a normal UEFI variable
because it cannot be stored on flash region even though it has the
NON_VOLATILE attribute. It is more like a virtual variable.</p>
</li>
</ul>
<p>A platform memory initialization module shall check the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/MemoryOverwriteControl.h" target="_blank">MemoryOverwriteRequestControl</a>
variable. If this variable is not present or this variable indicates a
MOR request, then the memory initialization module shall clear the
memory after enabling the memory controller. For example, the
<a href="https://github.com/tianocore/edk2-platforms/blob/master/Platform/Intel/QuarkPlatformPkg/Platform/Pei/PlatformInit/MrcWrapper.c" target="_blank">QuarkPlatformMemoryInit</a>
module <strong>InstallEfiMemory</strong>() function checks the MOR variable and zeros
all system memory before installing it if MOR_CLEAR_MEMORY_VALUE() is
TRUE. Another example is the Kabylake openboard
<a href="https://github.com/tianocore/edk2-platforms/blob/master/Platform/Intel/KabylakeOpenBoardPkg/KabylakeRvp3/FspWrapper/Library/PeiSiliconPolicyUpdateLibFsp/PeiFspMiscUpdUpdateLib.c" target="_blank">FspmPolicyWrapper</a>
<strong>PeiFspMiscUpdUpdatePreMem</strong>() function that checks the MOR variable
and sets the CleanMemory policy data if MOR_CLEAR_MEMORY_BIT_MASK is
set.</p>
<p>The MOR variable is managed by the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/MemoryOverwriteControl" target="_blank">MemoryOverwriteControl</a>
module. The MOR variable is created at
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/MemoryOverwriteControl/TcgMor.c" target="_blank">TcgMor.c</a>
entrypoint <strong>MorDriverEntryPoint</strong>(), and the variables is cleared at
the ReadyToBoot event <strong>OnReadyToBoot</strong>().</p>
<p>Because the MOR variable is read/write, a malicious software entity may
just clear the MOR request even if a high privileged software requests
the MOR. We need a secure MOR solution to prevent such an attack. The
MorLock variable was introduced to protect the MOR variable. The first
version of MorLock is simple. Once the MorLock is set, no one can unlock
MOR until the next boot. It is secure, but it brings performance
overhead for a system reset. People have to wait a long time for the
platform memory module cleaning all system memory, especially on a
server platform with large memory. The second MorLock supports unlock.
The MorLock caller can set MorLock with an 8 byte secret key. If the
caller sets MorLock with the same 8 bytes secret key, it means unlock
MOR. In order to prevent secret key guessing, any wrong secret key will
cause the MorLock to become unlockable in the current boot.</p>
<p>Because the variable driver must save a secret key, the variable driver
shall:</p>
<p>1)  execute in a secure execution environment, such as system management
    mode (SMM).</p>
<p>2)  not store the secret key content to a non-volatile storage, such as
    an SPI flash region.</p>
<p>The MorLock variable is managed by the EDKII
<a href="https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Universal/Variable/RuntimeDxe" target="_blank">VariableRuntimeDxe</a>
driver
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Universal/Variable/RuntimeDxe/TcgMorLockSmm.c" target="_blank">TcgMorLockSmm.c</a>.
<strong>SetVariableCheckHandlerMorLock</strong>() function follows the specification
to handle both secure MOR version 1 (lock without key) and version 2
(lock with key).</p>
<p>Figure 11 shows the high level TCG MOR Flow.</p>
<p><img src="media/image11.png" alt="">{width=&quot;6.492361111111111in&quot;
height=&quot;2.3027777777777776in&quot;}</p>
<p>Figure 11 TCG MOR Flow</p>
<p>The MOR variable not only control memory overwrite but also control the
storage device TPer reset. We will discuss that in TCG storage section.</p>
<p>Previous MOR specifications also defined an ACPI interface. The OS may
set MOR state by using an ACPI _DSM method. This interface is
deprecated because it does not support secure MOR.</p>
<p>Figure 12 shows TCG MOR component in EDK II.</p>
<p><img src="media/image12.png" alt="">{width=&quot;6.5in&quot;
height=&quot;4.030555555555556in&quot;}</p>
<p>Figure 12 TCG MOR Component in EDK II</p>
<h2 id="os-interface">OS Interface</h2>
<p>A platform firmware shall report the TPM device to an OS. The report
should include 1) ACPI table, 2) EFI_TCG2_PROTOCOL.</p>
<h3 id="acpi-table">ACPI Table</h3>
<p>A TPM capable system shall report two ACPI tables.</p>
<p>1)  <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/Tpm2Acpi.h" target="_blank">TPM2
    ACPI</a>
    table -- This is a static table to report the TPM device control
    area and TCG event log.</p>
<p>2)  <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tpm.asl" target="_blank">TPM
    SSDT</a>
    ACPI table -- This is the ACPI language to declare the TPM device,
    describe the hardware resources, such as interrupt information, and
    provide the device specific method _DSM(), such as TCG Physical
    Presence (PP) operation.</p>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
installs <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/Tpm2Acpi.h" target="_blank">TPM2
ACPI</a>
table in <strong>PublishTpm2</strong>(). It uses the below PCDs to patch the table.</p>
<ul>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableRev</a> -
This is to indicate TPM2 ACPI table version: version 3 or version 4.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdTpmPlatformClass</a> -
This is to indicate the platform type: client or server.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableLaml</a>/<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableLasa</a>
-- This is for TCG event log area. Only version 4 table includes the
TCG event log field.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdActiveTpmInterfaceType</a>
-- These are for the TPM device interface: Tpm2PtpInterfaceCrb or
Tpm2PtpInterfaceFifo. Only Tpm2PtpInterfaceCrb interface requires
StartMethod and AddressOfControlArea.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpmBaseAddress</a>
-- This is for TPM device base address.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdAcpiDefaultOemId</a>,
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdAcpiDefaultOemTableId</a>,
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdAcpiDefaultOemRevision</a>,
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdAcpiDefaultCreatorId</a>,
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdAcpiDefaultCreatorRevision</a>
-- These are for the common ACPI header.</p>
</li>
</ul>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
installs the <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tpm.asl" target="_blank">TPM
SSDT</a>
ACPI table in <strong>PublishAcpiTable</strong>(). It uses the below PCDs to patch
the table.</p>
<ul>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcgPhysicalPresenceInterfaceVer</a>
-- This is to indicate the TCG Physical Presence Interface version.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2CurrentIrqNum</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2PossibleIrqNumBuf</a>
-- This is to indicate the TPM IRQ information.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdAcpiDefaultOemId</a>
-- This is for the common ACPI header. The OemTableId and
OemRevision should not be patched because they are defined at build
time -- &apos;TPM2Tabl&apos;. The CreatorId and CreatorRevision should not be
patched because the ASL compiler fills in those values.</p>
</li>
</ul>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
patches the TNVS ACPI OperationRegion with an ACPInvs memory address in
<strong>AssignOpRegion</strong>(). The TNVS is used as a runtime communication buffer
between ASL and the SMI handler <strong>PhysicalPresenceCallback</strong>() for the
TCG PP request.</p>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
patches _HID to indicate a TPM device to the OS in <strong>UpdateHID</strong>().
Tcg2Smm should get the TPM
<a href="https://trustedcomputinggroup.org/resource/vendor-id-registry/" target="_blank">vendorID</a>
from the <strong>Tpm2GetCapabilityManufactureID</strong>(), then translate the TPM
vendorID to the ACPI defined <a href="https://uefi.org/PNP_ACPI_Registry" target="_blank">PNPID</a>
and update the _HID name string. In a case that a company only
registered a TPM vendorID but not an ACPI PNPID, the translation fails.
The _CID(&quot;MSFT0101&quot;) should be used as _HID.</p>
<h3 id="tcg2protocol">TCG2_PROTOCOL</h3>
<p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
is to provide a TCG services to an OS loader. It is a boot service
protocol. It cannot be used after the ExitBootServices event.</p>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Dxe" target="_blank">Tcg2Dxe</a>
installs the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
and provides the below services:</p>
<ul>
<li><p><strong>GetCapability</strong>() -- This is to return capability information and
state information, such as HashAlgorithmBitmap, SupportedEventLogs,
TPMPresentFlag, NumberOfPCRBanks, ActivePcrBanks, etc.</p>
</li>
<li><p><strong>GetEventLog</strong>() -- This is to return the TCG event log.</p>
</li>
<li><p><strong>HashLogExtendEvent</strong>() -- This is to provide a service to extend
data and log events. It has a flag to measure a PE image directly.</p>
</li>
<li><p><strong>SubmitCommand</strong>() -- This is to submit a TPM command.</p>
</li>
<li><p><strong>GetActivePcrBanks</strong>() -- This is to get the active PCR banks.</p>
</li>
<li><p><strong>SetActivePcrBanks</strong>() -- This is to set the active PCR banks. It
will not take effect until the next reboot.</p>
</li>
<li><p><strong>GetResultOfSetActivePcrBanks</strong>() -- This is to return the result
of the last <strong>SetActivePcrBanks</strong>().</p>
</li>
</ul>
<h2 id="tcg-storage">TCG Storage</h2>
<p>The TCG not only defines the TPM device, but it also defines storage
devices, such as OPAL, Opalite, Pyrite, and Ruby.</p>
<p>EDK II
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/TcgStorageCoreLib.h" target="_blank">TcgStorageCoreLib</a>
provides interfaces for TCG storage, including the lowest level TCG data
encoding, such as TcgStartComPacket(), TcgEndComPacket(),
TcgStartPacket(), TcgEndPacket(), TcgStartSubPacket(),
TcgEndSubPacket(), TcgAddUINT8(), TcgAddUINT64(), TcgAddBOOLEAN(),
TcgAddTcgUid(), etc.</p>
<p>EDK II
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/TcgStorageOpalLib.h" target="_blank">TcgStorageOpalLib</a>
provides interfaces for TCG OPAL commands, such as OpalStartSession(),
OpalEndSession(), OpalPsidRevert(), OpalGetMsid(), OpalSetPassword(),
OpalBlockSid(), etc.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/StorageSecurityCommand.h" target="_blank">EFI_STORAGE_SECURITY_COMMAND_PROTOCOL</a>
is used to send a storage security command to a secure storage device.</p>
<p>The EDK II
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Opal/OpalPassword" target="_blank">OpalPassword</a>
driver handles all TCG storage features, such as OPAL device password
management and BlockSid.</p>
<h3 id="opal-password">OPAL Password</h3>
<p>The OPAL password feature is designed to replace the Hard Disk Drive
(HDD) password in the Advanced Technology Attachment (ATA)
specification. It lets a user set a password for the disk during
provisioning and requests the same password during every subsequent boot
to unlock the disk.</p>
<p>The EDK II
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Opal/OpalPassword" target="_blank">OpalPassword</a>
driver provides a setup user interface (UI) to let a user to input a
password to unlock the disk. At the driver entrypoint,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Opal/OpalPassword/OpalDriver.c" target="_blank">OpalDriver.c</a>
<strong>EfiDriverEntryPoint</strong>() installs the DriverBinding protocol and calls
<strong>HiiInstall</strong>() to install the setup form. Whenever there is an storage
device discovered, <strong>OpalEfiDriverBindingSupported</strong>() will check if the
device supports
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/StorageSecurityCommand.h" target="_blank">EFI_STORAGE_SECURITY_COMMAND_PROTOCOL</a>.
If supported, then <strong>OpalEfiDriverBindingStart</strong>() calls
<strong>OpalDiskInitialize</strong>() to initialize the device, such as getting
manufactured SID (MSID) and data removal mechanism information. Then
<strong>OpalEfiDriverBindingStart</strong>() calls <strong>OpalDriverRequestPassword</strong>() to
unlock the disk.</p>
<p>If the disk locking feature is not set, then there is no need to ask the
user to input a password. The function just returns.</p>
<p>If the disk locking feature is set, the disk will be in the locked
state. A password dialogue box will be pop up to ask user to input the
password. Then <strong>OpalDriverRequestPassword</strong>() calls
<strong>OpalUtilUpdateGlobalLockingRange</strong>() to try unlocking. If the disk is
unlocked, then the password is correct. It will be used for
auto-unlocking in S3 resume (we will discuss that later). If unlocking
fails, then the user will be asked to input the password again. The
maximum retry count is 5 times. After that, the system will shut down.</p>
<p>A system level cold reset causes disk device power off, in which case
the disk is locked. However, a warm reset may keep the disk device power
on, which cause the disk remaining in the unlocked state after reset. In
this condition, the OpalPassword driver still need to get the password
from the end user for auto-unlocking in S3 resume. As such,
<strong>OpalDriverRequestPassword</strong>() calls
<strong>OpalUtilUpdateGlobalLockingRange</strong>() to try locking the device. If the
user does not input the original password, the action will not success.
Once the disk is locked, then the password is correct.
<strong>OpalUtilUpdateGlobalLockingRange</strong>() is called again to unlock the
disk.</p>
<p>Sometimes, the platform may want to skip the OPAL password prompt. It
can be controlled by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdSkipOpalPasswordPrompt</a>.
An end user may also choose to skip the password input by using &apos;ESC&apos;.
In this password skip scenario, if the device is in the locked state,
the device will be kept in the locked state and continue booting. If the
device is unlocked, the system will be forced to shut down in order to
lock the device again.</p>
<p>OPAL disk auto-unlocking in S3 resume is a necessary feature because
there is no UI available in the S3 resume path to let an end user input
anything. What we need is to let the DXE OPAL driver save the password
to a secure place with confidentiality guarantee, and then another S3
resume OPAL driver can get the password and unlock the OPAL device. The
system management RAM (SMRAM) is a natural place to save the password
secret. There are two possible ways to achieve this:</p>
<ul>
<li><p>We can have an SMM OPAL password driver. The DXE OPAL driver passes
the password to the SMM OPAL driver on a normal boot. Then the PEI
S3 script uses a software system management interrupt (SMI) invokes
the SMM OPAL driver to unlock the device.</p>
</li>
<li><p>We can have a PEI OPAL password driver. The DXE OPAL driver saves
the password to a
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Include/Library/LockBoxLib.h" target="_blank">LockBox</a>
with a confidentiality attribute. The password won&apos;t be exposed by
an OS and it can only be retrieved in PEI S3 code. Each LockBox can
be uniquely identified by a GUID. As such, the PEI OPAL driver gets
the password from the same LockBox during the S3 resume and unlocks
the device.</p>
</li>
</ul>
<p>In the first version, we choose the SMM OPAL password solution. However,
we ran into complicated Direct Memory Access (DMA) protection issues
because it is complicated to enable I/O Memory Management Unit (IOMMU)
for device DMA protection inside of SMM. So now we choose the PEI OPAL
password solution. In a normal boot path, at EndOfDxe event
<strong>OpalEndOfDxeEventNotify</strong>(), the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Opal/OpalPassword/OpalDriver.c" target="_blank">OpalDriver.c</a>
<strong>BuildOpalDeviceInfo</strong>() routine collects all OPAL device and password
information and saves this to the OpalDevice LockBox and S3InitDevice
LockBox via <strong>SaveLockBox</strong>() and sets the confidentiality attribute via
<strong>SetLockBoxAttributes</strong>(LOCK_BOX_ATTRIBUTE_RESTORE_IN_S3_ONLY).
The OPAL password unlock must happen before EndOfDxe event because the
LockBox services are closed after EndOfDxe.</p>
<p>In the S3 resume path,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Opal/OpalPassword/OpalPasswordPei.c" target="_blank">OpalPasswordPei.c</a>
entry point <strong>OpalPasswordPeiInit</strong>() installs the
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Include/Ppi/StorageSecurityCommand.h" target="_blank">EDKII_PEI_STORAGE_SECURITY_CMD_PPI</a>.
Whenever there is a disk driver installed, the
<strong>OpalPasswordStorageSecurityPpiNotify</strong>() callback function is invoked.
Then <strong>UnlockOpalPasswordDevices</strong>() gets the LockBox information via
<strong>RestoreLockBox</strong>() and calls <strong>UnlockOpalPassword</strong>() to unlock the
device one by one.</p>
<h3 id="opal-features">OPAL Features</h3>
<p>An end user may want to update the OPAL password for a device. Usually,
an end user can go to the BIOS setup page to perform that action and the
new password will take effect immediately. However, that is not feasible
in the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Opal/OpalPassword" target="_blank">OpalPassword</a>
driver. Because the setup page is launched after EndOfDxe event, there
is no chance to save the new password for auto-unlocking. As such, the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Opal/OpalPassword" target="_blank">OpalPassword</a>
driver only allows the user to send a request and then reset the system.
The OPAL password update request will be served in the next boot. After
the disk is unlocked, the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Opal/OpalPassword/OpalDriver.c" target="_blank">OpalDriver.c</a>
<strong>OpalEfiDriverBindingStart</strong>() routine calls <strong>ProcessOpalRequest</strong>().</p>
<p>Besides the password update, the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Opal/OpalPassword" target="_blank">OpalPassword</a>
driver supports an additional set of requests, such as:</p>
<ul>
<li><p><strong>ProcessOpalRequestSetAdminPwd</strong>() -- Set admin password. The old
admin password is required here.</p>
</li>
<li><p><strong>ProcessOpalRequestSetUserPwd</strong>() -- Set user password. The old
user password is required here.</p>
</li>
<li><p><strong>ProcessOpalRequestSecureErase</strong>() -- Secure erase user data on the
disk. An admin or user password is required here.</p>
</li>
<li><p><strong>ProcessOpalRequestRevert</strong>() -- Admin based revert to factory
default. The admin password and manufactured SID (MSID) is required
here. MSID can be read via <strong>OpalUtilGetMsid</strong>(). The admin can
choose to keep the user data or destroy it.</p>
</li>
<li><p><strong>ProcessOpalRequestPsidRevert</strong>() -- Physical Presence SID (PSID)
based revert to factory default. PSID is a 32-character case
sensitive value that is shipped with the disk.</p>
</li>
<li><p><strong>ProcessOpalRequestDisableUser</strong>() -- Disable user. The admin
password is required here.</p>
</li>
<li><p><strong>ProcessOpalRequestEnableFeature</strong>() -- Enable OPAL feature. The
admin password and MSID are required here.</p>
</li>
</ul>
<p>Care must be taken given that the OPAL device may take long to finish an
Erase or Revert action. To give a better user experience, the OPAL
driver pops up a message to notify the user of this potential delay.</p>
<p>Figure 13 shows TCG storage component in EDK II.</p>
<p><img src="media/image13.png" alt="">{width=&quot;6.5in&quot;
height=&quot;4.166666666666667in&quot;} Figure 13 TCG Storage Component in EDK II</p>
<h3 id="blocksid">BlockSid</h3>
<p>Even if an OPAL device supports locking, an end user may choose to not
lock it. In this case, a malicious entity may set a password to lock the
OPAL device later and freeze the disk. In order to mitigate this attack,
we need block Secure Identifier (SID), even if we don&apos;t want to use it.</p>
<p>BlockSid is a policy. It can be controlled by the end user via TCG
Physical Presence (PP) interface, which we have discussed before.</p>
<p>In the normal boot path, at EndOfDxe event
<strong>OpalEndOfDxeEventNotify</strong>(),
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Opal/OpalPassword/OpalDriver.c" target="_blank">OpalDriver.c</a>
<strong>SendBlockSidCommand</strong>() checks
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tcg2PhysicalPresenceLib.h" target="_blank">TCG2_BIOS_STORAGE_MANAGEMENT_FLAG_ENABLE_BLOCK_SID</a>
from the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresenceFlags</a>
and sends an <strong>OpalBlockSid</strong>() command if it is set.</p>
<p>In the S3 resume path,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Opal/OpalPassword/OpalPasswordPei.c" target="_blank">OpalPasswordPei.c</a>
<strong>UnlockOpalPassword</strong>() checks the same flag and sends an
<strong>OpalBlockSid</strong>() command after it unlocks the devices one by one.</p>
<p>See Figure 10 and Figure 13 for the BlockSid action in PP and OPAL
driver.</p>
<h3 id="tper-reset">TPer reset</h3>
<p>When a platform firmware detects the MOR request, it means an unexpected
system reset happened and the system might not erase the secrets from
the memory. It also means the disk protected region might be also
unlocked. In order to mitigate the reset attack, the platform not only
cleans the memory content, but the platform also needs to issue a TPer
reset command to the TCG storage devices.</p>
<p>The
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/MemoryOverwriteControl" target="_blank">MemoryOverwriteControl</a>
module manages the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/MemoryOverwriteControl.h" target="_blank">MemoryOverwriteRequestControl</a>
(MOR) variable. At the EndOfDxe event,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/MemoryOverwriteControl/TcgMor.c" target="_blank">TcgMor.c</a>
<strong>TPerResetAtEndOfDxe</strong>() locates all security storage devices and sends
a TPer reset command in <strong>InitiateTPerReset</strong>().</p>
<p>The platform also needs to ensure all trusted storages are connected
before the EndOfDxe event. A PlatformBds module, such as
<a href="https://github.com/tianocore/edk2-platforms/blob/master/Platform/Intel/BoardModulePkg/Library/BoardBdsHookLib/BoardBdsHookLib.c" target="_blank">BoardBdsHookLib</a>,
needs to process the TCG MOR request. <strong>ProcessTcgMor</strong>() needs to check
if there is any MOR request and connect the platform specific trusted
storage.</p>
<p>See Figure 12 for the TPer reset action in MOR driver.</p>
<h1 id="other-trusted-boot-chains">Other Trusted Boot chains</h1>
<p>Besides EDK II, other firmware or firmware related boot loaders also
include the trusted boot chain.</p>
<h2 id="coreboot">coreboot</h2>
<p><a href="https://github.com/coreboot" target="_blank">coreboot</a> includes the measured boot flow.
It is a simplified version. Table 4 shows the usage in coreboot.</p>
<p>Table 4: coreboot TPM PCR Usage (Source: <a href="https://doc.coreboot.org/security/vboot/measured_boot.html" target="_blank">coreboot measured
boot</a>)</p>
<p>  <strong>PCR Index</strong>   <strong>PCR Usage</strong></p>
<hr>
<p>  0               Google vboot GBB flags
  1               Google vboot GBB HWID
  2               Core Root of Trust for Measurement (CRTM)
  3               Runtime data like hwinfo.hex or MRC cache.
  4               N/A
  5               N/A
  6               N/A
  7               N/A</p>
<p><a href="https://github.com/coreboot/vboot" target="_blank">vboot</a>
<a href="https://github.com/coreboot/vboot/blob/master/firmware/2lib/include/2api.h" target="_blank">2api.h</a>
defines two PCRs:</p>
<ul>
<li><p><strong>BOOT_MODE_PCR</strong>(0) -- It is to record the digest based on the
current developer and recovery mode flags in the Google Binary Blob
(GBB)</p>
</li>
<li><p><strong>HWID_DIGEST_PCR</strong>(1) -- It is to record the digest of the
hardware ID (HWID) from the GBB.</p>
</li>
</ul>
<p>In verstage,
<a href="https://github.com/coreboot/coreboot/blob/master/src/security/vboot/verstage.c" target="_blank">vboot_logic.c</a>
<strong>verstage_main</strong>() calls <strong>extend_pcrs</strong>() to extend two PCRs.
<a href="https://github.com/coreboot/coreboot/blob/master/src/security/vboot/tpm_common.c" target="_blank">tpm_common.c</a>
<strong>vboot_extend_pcr</strong>() calls
<a href="https://github.com/coreboot/vboot/blob/master/firmware/2lib/2api.c" target="_blank">2api.c</a>
<strong>vb2api_get_pcr_digest</strong>() to get the corresponding flags and HWID
digest from the GBB and extends them to the TPM.</p>
<p>Later, coreboot
<a href="https://github.com/coreboot/coreboot/blob/master/src/security/tpm/tspi/crtm.h" target="_blank">crtm.h</a>
defines two PCRs:</p>
<ul>
<li><p><strong>TPM_CRTM_PCR</strong>(2) -- It is for Core Root of Trust for
Measurement (CRTM) modules, including all stages, data and blobs.
These include COREBOOT CBFS (bootblock, fallback/verstage), FW_MAIN
CBFS (fallback/romstage, fspm, fallback/postcar, fallback/ramstage,
cpu_microcode_blob, fsps, vbt, fallback/dsdt.aml,
fallback/payload), RO_VPD, GBB, SI_DESC, SI_GBE.</p>
</li>
<li><p><strong>TPM_RUNTIME_DATA_PCR</strong>(3) -- It is for runtime changeable data.
Such as CMOS, SI_ME, RW_NVRAM.</p>
</li>
</ul>
<p><a href="https://github.com/coreboot/coreboot/blob/master/src/security/tpm/tspi/crtm.c" target="_blank">crtm.c</a>
<strong>tspi_measure_cbfs_hook</strong>() is the hook function to measure
different components in the coreboot file system (CBFS) data. The
CBFS_TYPE definition can be found at
<a href="https://github.com/coreboot/coreboot/blob/master/src/commonlib/bsd/include/commonlib/bsd/cbfs_serialized.h" target="_blank">cbfs_serialized.h</a>.
For example:</p>
<ul>
<li><p>CBFS_TYPE_MRC -- PCR2</p>
</li>
<li><p>CBFS_TYPE_STAGE -- PCR2</p>
</li>
<li><p>CBFS_TYPE_SELF -- PCR2</p>
</li>
<li><p>CBFS_TYPE_FIT -- PCR2</p>
</li>
<li><p>CBFS_TYPE_MRC_CACHE -- PCR3</p>
</li>
<li><p>Other -- runtime data go to PCR3, non-runtime data go to PCR2.</p>
</li>
</ul>
<p>After that,
<a href="https://github.com/coreboot/coreboot/blob/master/src/security/tpm/tspi/log.c" target="_blank">log.c</a>
<strong>tcpa_log_add_table_entry</strong>() appends the log to a tcpa table.</p>
<h2 id="grub2">Grub2</h2>
<p><a href="https://github.com/rhboot/grub2" target="_blank">Grub2</a> extends the trusted boot chain
from platform firmware into the OS. Table 5 shows the PCR usage in Grub.</p>
<p>Table 5: GRUB TPM PCR Usage (Source: <a href="https://www.gnu.org/software/grub/manual/grub/html_node/Measured-Boot.html" target="_blank">Grub2 Measured
Boot</a>)</p>
<p>+---------------+-----------------------------------------------------+
| <strong>PCR Index</strong> | <strong>PCR Usage</strong>                                       |
+---------------+-----------------------------------------------------+
| 8             | Grub command line:                                  |
|               |                                                     |
|               | All executed commands (including those from         |
|               | configuration files) will be logged and measured as |
|               | entered with a prefix of &quot;grub_cmd: &quot;              |
+---------------+-----------------------------------------------------+
|               | Kernel command line:                                |
|               |                                                     |
|               | Any command line passed to a kernel will be logged  |
|               | and measured as entered with a prefix of            |
|               | &quot;kernel_cmdline: &quot;                                 |
+---------------+-----------------------------------------------------+
|               | Module command line:                                |
|               |                                                     |
|               | Any command line passed to a kernel module will be  |
|               | logged and measured as entered with a prefix of     |
|               | &quot;module_cmdline: &quot;                                 |
+---------------+-----------------------------------------------------+
| 9             | Files:                                              |
|               |                                                     |
|               | Any file read by GRUB will be logged and measured   |
|               | with a descriptive text corresponding to the        |
|               | filename.                                           |
+---------------+-----------------------------------------------------+</p>
<p>Grub2
<a href="https://github.com/rhboot/grub2/blob/master/include/grub/tpm.h" target="_blank">tpm.h</a>
defines two PCR index:</p>
<ul>
<li><p><strong>GRUB_STRING_PCR</strong>(8) -- It is for the command line string.</p>
</li>
<li><p><strong>GRUB_BINARY_PCR</strong>(9) -- It is for a file binary.</p>
</li>
</ul>
<p><a href="https://github.com/rhboot/grub2/blob/master/grub-core/commands/tpm.c" target="_blank">tpm.c</a>
registers <strong>grub_tpm_verify_string</strong>() and
<strong>grub_tpm_verify_write</strong>() to a grub_file_verifier structure. They
will be called by <strong>grub_verify_string</strong>() and
<strong>grub_verifiers_open</strong>() in
<a href="https://github.com/rhboot/grub2/blob/master/grub-core/commands/verifiers.c" target="_blank">verifiers.c</a>.</p>
<p>when grub2 executes a command line such as
GRUB_VERIFY_MODULE_CMDLINE, GRUB_VERIFY_KERNEL_CMDLINE,
GRUB_VERIFY_COMMAND or grub_create_loader_cmdline() in
<a href="https://github.com/rhboot/grub2/blob/master/grub-core/lib/cmdline.c" target="_blank">cmdline.c</a>,
<strong>grub_verify_string</strong>() is used. Finally,
<strong>grub_tpm_verify_string</strong>() measures the string to PCR8.</p>
<p><strong>grub_verifiers_open</strong>() is registered as one of grub_file_filters
in
<a href="https://github.com/rhboot/grub2/blob/master/include/grub/file.h" target="_blank">file.h</a>.
Whenever grub uses
<a href="https://github.com/rhboot/grub2/blob/master/grub-core/kern/file.c" target="_blank">file.c</a>
<strong>grub_file_open</strong>() this filter is invoked. Finally,
<strong>grub_tpm_verify_write</strong>() measures the file binary to PCR9.</p>
<h2 id="linux-secure-boot-shim">Linux Secure Boot Shim</h2>
<p><a href="https://github.com/rhboot/shim" target="_blank">Shim</a> is used to extend the UEFI secure
boot concept to Linux. Table 6 shows the PCR usage in Shim.</p>
<p>Table 6: Shim TPM PCR Usage</p>
<p>+---------------+-----------------------------------------------------+
| <strong>PCR Index</strong> | <strong>PCR Usage</strong>                                       |
+===============+=====================================================+
| 4             | UEFI application, such as second_stage, FALLBACK,  |
|               | MOK_MANAGER.                                       |
+---------------+-----------------------------------------------------+
| 7             | UEFI variable, such as &quot;MokSBState&quot;.                |
|               |                                                     |
|               | Verification policy authority, such as &quot;Shim&quot;,      |
|               | &quot;db&quot;, &quot;MokList&quot;.                                    |
+---------------+-----------------------------------------------------+
| 14            | UEFI variable, such as &quot;MokList&quot;, &quot;MokListX&quot;,       |
|               | &quot;MokSBState&quot;.                                       |
+---------------+-----------------------------------------------------+</p>
<p><a href="https://github.com/rhboot/shim/blob/main/shim.c" target="_blank">shim.c</a>
<strong>start_image</strong>() supports to execute a UEFI application image, such as
second_stage, FALLBACK, MOK_MANAGER. It calls <strong>tpm_log_pe</strong>() to
measure it to PCR4.</p>
<p><a href="https://github.com/rhboot/shim" target="_blank">Shim</a> defines a set of UEFI variable to
store the shim variable.
<a href="https://github.com/rhboot/shim/blob/main/mok.c" target="_blank">mok.c</a>
<strong>import_mok_state</strong>() checks the mok_state_variables, such as
&quot;MokList&quot;, &quot;MokListX&quot;, &quot;MokSBState&quot;, &quot;MokDBState&quot;. In which, the
&quot;MokSBState&quot; variable is measured to PCR7 via
<strong>tpm_measure_variable</strong>(). The &quot;MokList&quot;, &quot;MokListX&quot;, &quot;MokSBState&quot;
variables are measured to PCR14 via <strong>tpm_log_event</strong>().</p>
<p>To follow the UEFI secure boot protocol,
<a href="https://github.com/rhboot/shim/blob/main/shim.c" target="_blank">shim.c</a>
<strong>verify_one_signature</strong>() will record &quot;Shim&quot; as the authority via
<strong>tpm_measure_variable</strong>(), if the <strong>AuthenticodeVerify</strong>() succeeds.
Also <strong>check_db_cert</strong>()/<strong>check_db_hash</strong>() will record &quot;db&quot;,
&quot;MokList&quot; as authority if verification succeeds.</p>
<h2 id="windows-bitlocker">Windows BitLocker</h2>
<p>Microsoft Windows BitLocker uses the below-listed PCRs. The legacy-boot
version of Windows used PCR[8, 9, 10, 11], while UEFI-based Windows
uses PCR[11, 12, 13, 14] for the BitLocker policies. Table 7 shows the
PCR usage in Windows BitLocker.</p>
<p>Table 7: Windows BitLocker PCR Usage (Source: <a href="https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-group-policy-settings" target="_blank">Windows
BitLocker</a>)</p>
<hr>
<p>  <strong>PCR Index</strong>   <strong>PCR Usage (Legacy)</strong>     <strong>PCR Usage (UEFI)</strong>
  8               NTFS Boot Sector           Reserved
  9               NTFS Boot Block            Reserved
  10              Boot Manager               Reserved
  11              BitLocker access control   BitLocker access control
  12              Reserved                   Data events and highly volatile events
  13              Reserved                   Boot Module Details
  14              Reserved                   Boot Authorities</p>
<hr>
<h1 id="looking-forward">Looking Forward</h1>
<p>In trusted boot, the goal of the measurement is to support attestation
later. The TPM implements the root of trust for storage (RTS) and the
root of trust for reporting (RTR). The root of trust for measurement
(RTM) can be implemented in static RTM (SRTM) or dynamic RTM (DRTM).
From a platform perspective, there are other ways to implement the
measurement and attestation.</p>
<h2 id="platform-root-of-trust---cerberus">Platform Root of Trust - Cerberus</h2>
<p>A platform root of trust (RoT) is an entity to authenticate the firmware
on the platform. One example is the OCP Project
<a href="https://github.com/opencomputeproject/Project_Olympus/blob/master/Project_Cerberus" target="_blank">Cerberus</a>.
The platform RoT may also collect measurements from the devices and
support remote attestation. Figure 14 shows the concept of platform RoT.</p>
<p><img src="media/image14.png" alt="">{width=&quot;6.492361111111111in&quot;
height=&quot;4.0in&quot;}</p>
<p>Figure 14. Platform Root of Trust</p>
<h2 id="device-root-of-trust---dice">Device Root of Trust - DICE</h2>
<p>A device root of trust (RoT) is the RoT for a specific device to verify
the mutable firmware and report the measurement. TCG defines the Device
Identifier Composition Engine (DICE) architecture for embedded devices
which do not have full TPM capability but still want to support
attestation. DICE uses a layering architecture. A layered TCB
architecture uses a constrained set of TCB capabilities to construct the
next TCB layer. Figure 15 shows the DICE asymmetric attestation
architecture. Similar to the TPM certificate, a DICE device can present
a DICE certificate as the identity for the device. Figure 16 shows the
DICE symmetric attestation architecture, which may be used in a resource
constrain environment. For more detail, please refer to <a href="https://trustedcomputinggroup.org/work-groups/dice-architectures/" target="_blank">TCG DICE
architecture</a>.</p>
<p><img src="media/image15.png" alt="">{width=&quot;6.426221566054243in&quot;
height=&quot;4.378205380577428in&quot;}</p>
<p>Figure 15. DICE implicit identity based attestation (source: <a href="https://trustedcomputinggroup.org/resource/implicit-identity-based-device-attestation/" target="_blank">DICE
Identity</a>)</p>
<p><img src="media/image16.png" alt="">{width=&quot;6.0641021434820646in&quot;
height=&quot;3.872992125984252in&quot;}</p>
<p>Figure 16. DICE symmetric identity based attestation (source: <a href="https://trustedcomputinggroup.org/resource/symmetric-identity-based-device-attestation/" target="_blank">DICE
symmetric
Identity</a>)</p>
<h2 id="server-management-domain-firmware">Server Management Domain Firmware</h2>
<p>A server management domain (such as Baseboard Management Controller,
also known as BMC) may have its own TPM module and SRTM because of its
isolated execution environment. Table 8 shows the TPM PCR usage in a
server management domain. For more details, please refer to <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_ServerManagementDomainFirmwareProfile_v1p00_11aug2020.pdf" target="_blank">TCG Server
Management Domain Firmware
Specification</a>.</p>
<p>Table 8: TPM PCR Usage in Management Domain (Source: <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_ServerManagementDomainFirmwareProfile_v1p00_11aug2020.pdf" target="_blank">TCG
Server</a>)</p>
<p>  <strong>PCR Index</strong>   <strong>PCR Usage</strong></p>
<hr>
<p>  0               SRTM and Boot Loader
  1               Management Domain Configuration
  2               Loadable Devices
  3               Loadable Devices Configuration
  4               Reserved for future
  5               Reserved for future
  6               Vendor Specific
  7               Reserved for future
  8               For management domain OS
  9               For management domain OS configuration
  10~15          Reserved for future
  16              Debug
  17~23          Reserved for future</p>
<h2 id="secure-communication----spdm">Secure communication -- SPDM</h2>
<p>Now we have multiple device entities on the platform. We need a secure
communication mechanism. The Desktop Management Taskforce (DMTF) Secure
Protocol and Data Model (SPDM) serves that purpose. SPDM defines message
formats, data objects, and sequences for performing message exchanges.
The protocols defined by SPDM can be used for a wide range of security
functions. The SPDM protocol is similar to the network Transport Layer
Security (TLS) protocol, but it is customized for the communication
between two device entities.</p>
<p>SPDM 1.0 defines messages for hardware and firmware identification and
authentication, including messages for hardware and firmware measurement
collection and attestation. See Figure 4-3A. SPDM 1.1 defines a secure
session establishment mechanism between two entities by using Diffie
Hellman ephemeral (DHE) or Elliptic Curve DHE (ECDHE) key exchange with
asymmetric authentication such as RSA or Elliptic Curve Digital
Signature Algorithm (ECDSA). For a device that only supports symmetric
cryptography, the secure session can also be established with a
pre-shared key (PSK). Once the session is created, two entities can use
Authentication Encryption and Associated Data (AEAD) for message
communication. See Figure 4-3B. For more detail, please refer to <a href="https://www.dmtf.org/sites/default/files/standards/documents/DSP0274_1.1.0.pdf" target="_blank">DMTF
SPDM
Specification</a>.</p>
<p><img src="media/image17.png" alt="">{width=&quot;6.5in&quot;
height=&quot;3.9166666666666665in&quot;}</p>
<p>Figure 17. SPDM 1.0 (source:
<a href="https://www.dmtf.org/sites/default/files/standards/documents/DSP0274_1.1.0.pdf" target="_blank">SPDM</a>)</p>
<p><img src="media/image18.png" alt="">{width=&quot;6.5in&quot;
height=&quot;2.6666666666666665in&quot;}</p>
<p>Figure 18. SPDM 1.1 (source:
<a href="https://www.dmtf.org/sites/default/files/standards/documents/DSP0274_1.1.0.pdf" target="_blank">SPDM</a>)</p>
<p>Currently <a href="https://github.com/jyao1/openspdm" target="_blank">openspdm</a> project provides
an open source tool to validate the SPDM implementation and some sample
code for explaining the SPDM concept. Figure 4-4 shows the openspdm
internal design.</p>
<p><img src="media/image19.png" alt="">{width=&quot;6.5in&quot;
height=&quot;2.954861111111111in&quot;}</p>
<p>Figure 19. openspdm design (Source: <a href="https://github.com/jyao1/openspdm/blob/master/Doc/Design.md" target="_blank">openspdm
doc</a>)</p>
<h2 id="an-open-trusted-platform----putting-it-all-together">An Open Trusted Platform -- Putting it all together</h2>
<p>To put all of the above technology together, Figure 4-5 shows an example
of an open trusted platform.</p>
<p><img src="media/image20.png" alt="">{width=&quot;6.5in&quot;
height=&quot;4.166666666666667in&quot;}</p>
<p>Figure 20. An Open Trusted Platform</p>
<p><em>\
</em></p>
<h1 id="checklist-for-the-platform-developer">Checklist for the Platform Developer</h1>
<h2 id="pcr-measurement-and-attestation">PCR, Measurement and Attestation</h2>
<h3 id="general-guideline">General Guideline</h3>
<p>1.1.1. Use an <strong>even PCR for code</strong> measurement in general.</p>
<p>1.1.2. Use an <strong>odd PCR for data</strong> measurement in general.</p>
<p>1.1.3. Do <strong>NOT</strong> record data that <strong>that are dynamic and changeable
across the boot</strong>, such as system clock, fan speed, boot count, system
reset reason, battery power, a nonce value, a pointer, etc.</p>
<p>1.1.4. Do <strong>NOT</strong> record the <strong>instance of specific information that may
be used to unique identify a system</strong>, such as an asset tag, a serial
number, etc.</p>
<p>1.1.5. Do <strong>NOT</strong> record <strong>any privacy sensitive information</strong>.</p>
<h3 id="pcr-0">PCR 0</h3>
<p>1.2.1. Do configure
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdTcgPfpMeasurementRevision</a>
to select TCG PFP compliance revision.</p>
<p>1.2.2. Do configure
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdFirmwareVersionString</a>
to a valid Unicode string for version, so that it can be measured.</p>
<p>1.2.3. Do report <strong>all FV information</strong> in PEI, so that all of them can
be measured.</p>
<p>1.2.4. Do install
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/FirmwareVolumeInfoMeasurementExcluded.h" target="_blank">EFI_PEI_FIRMWARE_VOLUME_INFO_MEASUREMENT_EXCLUDED_PPI</a>
for the FV that is ready measured.</p>
<p>1.2.5. Do measure individual non-FV component, if it is loaded from the
platform firmware.</p>
<p>1.2.6. Do NOT update the loaded component before measuring it.</p>
<p>1.2.7. Do measure the non-host platform information using
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_INFO</a>,
if it exists.</p>
<p>1.2.8. Do measure the non-host platform component using
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_CODE</a>
if it can only be updated by the platform firmware.</p>
<h3 id="pcr-1">PCR 1</h3>
<p>1.3.1. Do measure Microcode.</p>
<p>1.3.2. Do measure SMBIOS table after filtering changeable data or
instance data.</p>
<p>1.3.3. Do measure &quot;Entering ROM Based Setup&quot; with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_ACTION</a>
for a setup utility.</p>
<p>1.3.4. Do measure security related configuration data from non-volatile
storage, such as UEFI setup variable, or CMOS.</p>
<p>1.3.5. Do measure the hardware device list with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_TABLE_OF_DEVICES</a>.</p>
<p>1.3.6. Do measure the non-host platform configuration using
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_CONFIG</a>
if it can only be updated by the platform firmware.</p>
<h3 id="pcr-2">PCR 2</h3>
<p>1.4.1. Do link
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeTpm2MeasureBootLib" target="_blank">DxeTpm2MeasureBootLib</a>
as <strong>LAST</strong> NULL instance lib for SecurityStubDxe.inf in a DSC file.</p>
<p>1.4.2. Do measure the non-host platform component using
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_CODE</a>
if it can be updated by entities other than the platform firmware.</p>
<p>1.4.3. Do measure SPDM-capable device hardware or firmware use
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_SPDM_FIRMWARE_BLOB</a>.</p>
<h3 id="pcr-3">PCR 3</h3>
<p>1.5.1. Do measure &quot;Entering ROM Based Setup&quot; with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_ACTION</a>
for a UEFI application based setup utility.</p>
<p>1.5.2. Do measure the non-host platform configuration using
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_CONFIG</a>
if it can be updated by entities other than the platform firmware.</p>
<p>1.5.3. Do measure SPDM-capable device hardware configuration or firmware
configuration use
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_SPDM_FIRMWARE_CONFIG</a>.</p>
<h3 id="pcr-4">PCR 4</h3>
<p>1.6.1. Do measure the additional pre-OS code loaded by an UEFI
application the using EV_COMPACT_HASH.</p>
<h3 id="pcr-5">PCR 5</h3>
<p>1.7.1 Do measure the additional data configuration related to the UEFI
application.</p>
<h3 id="pcr-6">PCR 6</h3>
<p>N/A</p>
<h3 id="pcr-7">PCR 7</h3>
<p>1.9.1. Do measure <strong>security configuration</strong> if it exits. (It means the
whole policy.)</p>
<p>1.9.2. Do measure <strong>security authority</strong> if it exits. (It means the
specific policy which is used to verify the component.)</p>
<p>1.9.3. Do measure the security feature disabling event, such as &quot;UEFI
Debug Mode&quot;, &quot;DMA Protection Disabled&quot;.</p>
<h3 id="noaction-event">NO_ACTION event</h3>
<p>1.10.1. Do record startup locality event, if an ACM starts the TPM.</p>
<h2 id="tpm-device-startup">TPM Device Startup</h2>
<h3 id="device-selection">Device Selection</h3>
<p>2.1.1. Do NOT support TPM1.2.</p>
<p>2.1.2. Do choose a proper Tcg2Config driver for device selection, such
as
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Config" target="_blank">Tcg2Config</a>
or platform specific one.</p>
<p>2.1.3. Do set
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpmInstanceGuid</a>
directly after the TPM device selection.</p>
<p>2.1.4. Do set
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2InitializationPolicy</a>
if the TPM device is started.</p>
<h3 id="tpm-device-interface">TPM Device Interface</h3>
<p>2.2.1. Do link proper
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tpm2DeviceLib.h" target="_blank">Tpm2DeviceLib</a>
to Tcg2Dxe.inf and Tcg2Pei.inf in platform DSC, such as
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/Tpm2DeviceLibDTpm" target="_blank">Tpm2DeviceLibDTpm</a>
or other TPM device such as I2C.</p>
<h3 id="error-handling">Error Handling</h3>
<p>2.3.1. Do register a ReportStatusCode callback handler to process the
TPM error, if the platform wants to reset system, or disable the TPM
hardware on error.</p>
<h2 id="tcg-physical-presence">TCG Physical Presence</h2>
<p>3.1.1. Do call <strong>Tcg2PhysicalPresenceLibNeedUserConfirm</strong>() and
<strong>Tcg2PhysicalPresenceLibProcessRequest</strong>() in the platform BDS before
EndOfDxe.</p>
<p>3.1.2. Do <strong>connect all trusted consoles</strong> if
<strong>Tcg2PhysicalPresenceLibNeedUserConfirm</strong>() is TRUE.</p>
<h3 id="tpm-bank-selection">TPM Bank Selection</h3>
<p>3.2.1. Do choose
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashLibBaseCryptoRouter" target="_blank">HashLibBaseCryptoRouter</a>
if the platform wants to support crypto agile.</p>
<p>3.2.2. Do link proper multiple HashLib instances, such as
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashInstanceLibSha256" target="_blank">HashInstanceLibSha256</a>,
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashInstanceLibSha384" target="_blank">HashInstanceLibSha384</a>,
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashInstanceLibSha512" target="_blank">HashInstanceLibSha512</a>
and
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashInstanceLibSm3" target="_blank">HashInstanceLibSm3</a>,
to Tcg2Pei.inf and Tcg2Dxe.inf in platform DSC.</p>
<p>3.2.3. Do NOT use
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashInstanceLibSha1" target="_blank">HashInstanceLibSha1</a>.</p>
<h3 id="tpm-hierarchy-management">TPM Hierarchy Management</h3>
<p>3.3.1. Do choose a proper Tcg2Platform module to manage the TPM platform
hierarchy, such as
<a href="https://github.com/tianocore/edk2-platforms/tree/master/Platform/Intel/MinPlatformPkg/Tcg" target="_blank">Tcg2Platform</a>
or platform specific one.</p>
<p>3.3.2. Do randomize TPM platform auth before EndOfDxe.</p>
<p>3.3.3. Do randomize TPM platform auth before EndOfPei in S3 resume, if
TPM error happens.</p>
<p>3.3.4. Do send <strong>Tpm2HierarchyControl</strong>() command to enable or disable
the hierarchy, if it is supported.</p>
<h2 id="tcg-memory-override">TCG Memory Override</h2>
<p>4.1.1. Do check MOR variable and clear memory in memory initialization
if MOR request is set.</p>
<p>4.1.2. Do treat MOR variable missing as requested.</p>
<h2 id="os-interface">OS Interface</h2>
<h3 id="acpi-table">ACPI Table</h3>
<p>5.1.1. Do configure
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableRev</a>
to indicate TPM2 ACPI table version.</p>
<p>5.1.2. Do configure
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdTpmPlatformClass</a>
for client or server.</p>
<p>5.1.3. Do configure
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcgPhysicalPresenceInterfaceVer</a>
to indicate the TCG Physical Presence Interface version.</p>
<p>5.1.4. Do configure
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2CurrentIrqNum</a>
and
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2PossibleIrqNumBuf</a>
to indicate the TPM IRQ information.</p>
<h3 id="tcg2protocol">TCG2_PROTOCOL</h3>
<p>N/A</p>
<h2 id="tcg-storage">TCG Storage</h2>
<h3 id="opal-password">OPAL Password</h3>
<p>6.1.1. Do <strong>connect trusted storages and trusted consoles</strong> in Platform
BDS before EndOfDxe if there is OPAL password request.</p>
<p>6.1.2. Do include storage disk drivers in PEI for S3 auto-unlock.</p>
<h3 id="opal-feature">OPAL Feature</h3>
<p>6.2.1. Do <strong>connect trusted storages and trusted consoles</strong> in Platform
BDS before EndOfDxe if there is OPAL feature request.</p>
<h3 id="blocksid">BlockSid</h3>
<p>6.3.1. Do enable BlockSid by default.</p>
<h3 id="tper-reset">TPer reset</h3>
<p>6.4.1. Do <strong>connect trusted storages</strong> in Platform BDS before EndOfDxe
if MOR request is set.</p>
<p>6.4.2. Do treat MOR variable missing as requested.</p>
<h1 id="glossary">Glossary</h1>
<p>ACM -- Authenticated Code Module (Intel)</p>
<p>AEAD -- Authenticated Encryption with Associated Data</p>
<p>APCI -- Advanced Power and Configuration Interface</p>
<p>CoSWID -- Concise SWID</p>
<p>CCC -- Confidential Computing Consortium</p>
<p>CRB -- Command Response Buffer</p>
<p>DHE -- Diffie-Hellman ephemeral (key exchange)</p>
<p>DICE -- Device Identifier Composition Engine</p>
<p>DMA -- Direct Memory Access</p>
<p>DRTM -- Dynamic Root of Trust for Measurement</p>
<p>ECDHE -- Elliptic Curve DHE (key exchange)</p>
<p>ECDSA -- Elliptic Curve Digital Signature Algorithm</p>
<p>FIM -- Firmware Integrity Measurement</p>
<p>GP -- Global Platform</p>
<p>IBV -- Independent BIOS Vendor</p>
<p>IFV -- Independent Firmware Vendor</p>
<p>IHV -- Independent Hardware Vendor</p>
<p>ISV -- Independent Silicon Vendor</p>
<p>MAC -- Message Authentication Code</p>
<p>MMIO -- Memory Mapped I/O</p>
<p>MOR -- Memory Overwrite</p>
<p>MSID -- Manufactured SID</p>
<p>ODM -- Original Design Manufacturer</p>
<p>OEM -- Original Equipment Manufacturer</p>
<p>OSV -- Operating System Vendor</p>
<p>PFP -- TCG Platform Firmware Profile specification</p>
<p>PI -- Platform Initialization (UEFI)</p>
<p>PP -- Physical Presence</p>
<p>PSID -- Physical Presence SID</p>
<p>PSK -- Pre-shared key</p>
<p>PTP --Platform TPM Profile</p>
<p>RIM -- TCG Reference Integrity Manifest</p>
<p>RoT -- Root of Trust</p>
<p>RSA -- Rivest Shamir Adlemann (algorithm)</p>
<p>RTM -- Root of Trust for Measurement</p>
<p>SID -- TCG Storage Secure Identifier</p>
<p>SMBIOS -- DMTF System Management BIOS</p>
<p>SMM -- x86 System Management Mode.</p>
<p>SP -- Storage Security Provider</p>
<p>SPDM -- Secure Protocol and Data Model (DMTF)</p>
<p>SRTM -- Static Root of Trust for Measurement</p>
<p>SWID -- Software Identification</p>
<p>TCB -- Trust Computing Base</p>
<p>TCG -- Trust Computing Group</p>
<p>TEE -- Trusted Execution Environment</p>
<p>TLS -- Transport Layer Security</p>
<p>TPer -- Trusted Peripheral</p>
<p>TPM -- Trust Platform Module</p>
<p>TSS -- TPM Software Stack</p>
<p>TZ -- TrustZone (ARM)</p>
<p>UEFI -- Unified Extensible Firmware Interface</p>
<h1 id="references">References</h1>
<h2 id="books">Books</h2>
<p>[Building Secure Firmware] Jiewen Yao, Vincent Zimmer, <em>Building
Secure Firmware: Armoring the Foundation of the Platform</em>, 2020, Apress,
<a href="https://intel-my.sharepoint.com/personal/vincent_zimmer_intel_com/Documents/Documents/https" target="_blank">https</a><a href="https://www.amazon.com/gp/product/1484261054/" target="_blank">://www.amazon.com/gp/product/1484261054/</a>,</p>
<p><a href="https://link.springer.com/content/pdf/10.1007%2F978-1-4842-6106-4.pdf" target="_blank">https://link.springer.com/content/pdf/10.1007%2F978-1-4842-6106-4.pdf</a></p>
<p>[TPM2.0 Book] Will Arthur, David Challener, <em>A Practical Guide to
TPM2.0</em>, 2015, Apress,
<a href="https://www.amazon.com/Practical-Guide-TPM-2-0-Platform-ebook/dp/B0781D8J6W" target="_blank">https://www.amazon.com/Practical-Guide-TPM-2-0-Platform-ebook/dp/B0781D8J6W</a>,
<a href="https://link.springer.com/book/10.1007%2F978-1-4302-6584-9" target="_blank">https://link.springer.com/book/10.1007%2F978-1-4302-6584-9</a></p>
<h2 id="specifications">Specifications</h2>
<p>[NIST SP800-155] BIOS Integrity Measurement Guidelines, 2011,
<a href="https://csrc.nist.gov/publications/detail/sp/800-155/draft" target="_blank">https://csrc.nist.gov/publications/detail/sp/800-155/draft</a></p>
<p>[NIST SWID] Software Identification SWID,
<a href="https://csrc.nist.gov/projects/Software-Identification-SWID" target="_blank">https://csrc.nist.gov/projects/Software-Identification-SWID</a></p>
<p>[NIST IR8086] NISTIR.8060 Guidelines for the Creation of Interoperable
SWID Tags, <a href="https://csrc.nist.gov/publications/detail/nistir/8060/final" target="_blank">https://csrc.nist.gov/publications/detail/nistir/8060/final</a></p>
<p>[IETF CoSWID] Concise Software Identification Tags,
<a href="https://datatracker.ietf.org/doc/draft-ietf-sacm-coswid/" target="_blank">https://datatracker.ietf.org/doc/draft-ietf-sacm-coswid/</a></p>
<p>[IETF CoSWID-RIM] Reference Integrity Measurement Extension for
Concise Software Identities,
<a href="https://datatracker.ietf.org/doc/draft-birkholz-rats-coswid-rim/" target="_blank">https://datatracker.ietf.org/doc/draft-birkholz-rats-coswid-rim/</a></p>
<p>[TCG RIM-IM] TCG Reference Integrity Manifest Information Model
Specification, 2020,
<a href="https://trustedcomputinggroup.org/resource/tcg-reference-integrity-manifest-rim-information-model/" target="_blank">https://trustedcomputinggroup.org/resource/tcg-reference-integrity-manifest-rim-information-model/</a></p>
<p>[TCG PC Client RIM] TCG PC Client Reference Integrity Manifest
Specification, 2020,
<a href="https://trustedcomputinggroup.org/resource/tcg-pc-client-reference-integrity-manifest-specification/" target="_blank">https://trustedcomputinggroup.org/resource/tcg-pc-client-reference-integrity-manifest-specification/</a></p>
<p>[TCG PC Client FIM] TCG PC Client Platform Firmware Integrity
Measurement Specification, 2020,</p>
<p>[TCG PC Client PFP] TCG PC Client Platform Firmware Profile
Specification, 2020,
<a href="https://trustedcomputinggroup.org/resource/pc-client-specific-platform-firmware-profile-specification/" target="_blank">https://trustedcomputinggroup.org/resource/pc-client-specific-platform-firmware-profile-specification/</a>,
<a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PCClient_PFP_r1p05_v22_02dec2020.pdf" target="_blank">https://trustedcomputinggroup.org/wp-content/uploads/TCG_PCClient_PFP_r1p05_v22_02dec2020.pdf</a></p>
<p>[TCG PC Client PTP] TCG PC Client Platform TPM Profile Specification,
2020,
<a href="https://trustedcomputinggroup.org/resource/pc-client-platform-tpm-profile-ptp-specification/" target="_blank">https://trustedcomputinggroup.org/resource/pc-client-platform-tpm-profile-ptp-specification/</a>,</p>
<p>[TCG Physical Presence] TCG PC Client Platform Physical Presence
Interface Specification, 2015,
<a href="https://trustedcomputinggroup.org/resource/tcg-physical-presence-interface-specification/" target="_blank">https://trustedcomputinggroup.org/resource/tcg-physical-presence-interface-specification/</a></p>
<p>[TCG MOR] TCG PC Client Platform Reset Attack Mitigation
Specification, 2019,
<a href="https://trustedcomputinggroup.org/resource/pc-client-work-group-platform-reset-attack-mitigation-specification/" target="_blank">https://trustedcomputinggroup.org/resource/pc-client-work-group-platform-reset-attack-mitigation-specification/</a></p>
<p>[TCG TPM ACPI] &quot;TCG ACPI Specification, 2017,
<a href="https://trustedcomputinggroup.org/resource/tcg-acpi-specification/" target="_blank">https://trustedcomputinggroup.org/resource/tcg-acpi-specification/</a></p>
<p>[TCG UEFI Protocol] TCG EFI Protocol Specification, 2016,
<a href="https://trustedcomputinggroup.org/resource/tcg-efi-protocol-specification/" target="_blank">https://trustedcomputinggroup.org/resource/tcg-efi-protocol-specification/</a></p>
<p>[TCG Storage] TCG Storage Architecture Core Specification,
<a href="https://trustedcomputinggroup.org/tcg-storage-architecture-core-specification/" target="_blank">https://trustedcomputinggroup.org/tcg-storage-architecture-core-specification/</a></p>
<p>[TCG SIIS] TCG Storage Interface Interactions Specification,
<a href="https://trustedcomputinggroup.org/resource/storage-work-group-storage-interface-interactions-specification/" target="_blank">https://trustedcomputinggroup.org/resource/storage-work-group-storage-interface-interactions-specification/</a></p>
<p>[TCG OPAL] Storage Work Group Storage Security Subsystem Class: Opal,
<a href="https://trustedcomputinggroup.org/storage-work-group-storage-security-subsystem-class-opal/" target="_blank">https://trustedcomputinggroup.org/storage-work-group-storage-security-subsystem-class-opal/</a></p>
<p>[TCG Pyrite] Storage Work Group Storage Security Subsystem Class:
Pyrite,
<a href="https://trustedcomputinggroup.org/resource/tcg-storage-security-subsystem-class-pyrite/" target="_blank">https://trustedcomputinggroup.org/resource/tcg-storage-security-subsystem-class-pyrite/</a></p>
<p>[TCG Ruby] Storage Work Group Storage Security Subsystem Class: Ruby,
<a href="https://trustedcomputinggroup.org/resource/tcg-storage-security-subsystem-class-ruby-specification/" target="_blank">https://trustedcomputinggroup.org/resource/tcg-storage-security-subsystem-class-ruby-specification/</a></p>
<p>[TCG BlockSID] TCG Storage Feature Set: Block SID Authentication,
2015,
<a href="https://trustedcomputinggroup.org/resource/tcg-storage-feature-set-block-sid-authentication-specification/" target="_blank">https://trustedcomputinggroup.org/resource/tcg-storage-feature-set-block-sid-authentication-specification/</a>,
<a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_Storage_BlockIDAuth_v1p01_r1p14_13jan2021.pdf" target="_blank">https://trustedcomputinggroup.org/wp-content/uploads/TCG_Storage_BlockIDAuth_v1p01_r1p14_13jan2021.pdf</a></p>
<p>[TCG PSID] TCG Storage Feature Set: PSID,
<a href="https://trustedcomputinggroup.org/resource/tcg-storage-opal-feature-set-psid/" target="_blank">https://trustedcomputinggroup.org/resource/tcg-storage-opal-feature-set-psid/</a></p>
<p>[TCG Vendor ID] TCG TPM Vendor ID Registry,
<a href="https://trustedcomputinggroup.org/resource/vendor-id-registry/" target="_blank">https://trustedcomputinggroup.org/resource/vendor-id-registry/</a></p>
<p>[TCG DICE Identity] Implicit Identity Based Device Attestation, 2018,
<a href="https://trustedcomputinggroup.org/resource/implicit-identity-based-device-attestation/" target="_blank">https://trustedcomputinggroup.org/resource/implicit-identity-based-device-attestation/</a></p>
<p>[TCG DICE Symmetric Identity] Symmetric Identity Based Device
Attestation, 2020,
<a href="https://trustedcomputinggroup.org/resource/symmetric-identity-based-device-attestation/" target="_blank">https://trustedcomputinggroup.org/resource/symmetric-identity-based-device-attestation/</a></p>
<p>[TCG DICE Layer] DICE Layering Architecture, 2020,
<a href="https://trustedcomputinggroup.org/resource/dice-layering-architecture/" target="_blank">https://trustedcomputinggroup.org/resource/dice-layering-architecture/</a></p>
<p>[TCG Server Domain] TCG Server Management Domain Firmware Profile,
2020,
<a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_ServerManagementDomainFirmwareProfile_v1p00_11aug2020.pdf" target="_blank">https://trustedcomputinggroup.org/wp-content/uploads/TCG_ServerManagementDomainFirmwareProfile_v1p00_11aug2020.pdf</a></p>
<p>[ACPI] ACPI specification, 2019, <a href="https://www.uefi.org/specifications" target="_blank">https://www.uefi.org/specifications</a></p>
<p>[ACPI and PnP vendor IDs] <a href="https://uefi.org/PNP_ACPI_Registry" target="_blank">https://uefi.org/PNP_ACPI_Registry</a></p>
<p>[SMBIOS] DSP0134 System Management BIOS specification, 2020,
<a href="https://www.dmtf.org/standards/smbios" target="_blank">https://www.dmtf.org/standards/smbios</a></p>
<p>[SPDM] DSP0274 Security Protocol and Data Model Specification, 2020,
<a href="https://www.dmtf.org/standards/pmci" target="_blank">https://www.dmtf.org/standards/pmci</a></p>
<p>[Cerberus] Project Cerberus Architecture Overview, 2018,
<a href="https://github.com/opencomputeproject/Project_Olympus/blob/master/Project_Cerberus/Project%20Cerberus%20Architecture%20Overview.pdf" target="_blank">https://github.com/opencomputeproject/Project_Olympus/blob/master/Project_Cerberus</a></p>
<p>[AMD] AMD Architecture Programmer&apos;s Manual, 2019,
<a href="https://developer.amd.com/resources/developer-guides-manuals/" target="_blank">https://developer.amd.com/resources/developer-guides-manuals/</a></p>
<p>[Intel SDM] Intel 64 and IA-32 Architecture Software Developer
Manuals, 2019, <a href="https://software.intel.com/en-us/articles/intel-sdm" target="_blank">https://software.intel.com/en-us/articles/intel-sdm</a></p>
<p>[Intel FSP] Intel Firmware Support Package External Architecture
Specification,
<a href="https://software.intel.com/content/www/us/en/develop/articles/intel-firmware-support-package.html" target="_blank">https://software.intel.com/content/www/us/en/develop/articles/intel-firmware-support-package.html</a></p>
<p>[TrustZone] ARM TrustZone,
<a href="https://developer.arm.com/ip-products/security-ip/trustzone" target="_blank">https://developer.arm.com/ip-products/security-ip/trustzone</a></p>
<h2 id="internet-links">Internet Links</h2>
<p>[TCG] Trusted Computing Group, <a href="https://trustedcomputinggroup.org/" target="_blank">https://trustedcomputinggroup.org/</a></p>
<p>[CCC] Confidential Computing Consortium,
<a href="https://confidentialcomputing.io/" target="_blank">https://confidentialcomputing.io/</a></p>
<p>[TEE] Confidential Computing: Hardware-Based Trusted Execution for
Applications and Data, 2020,
<a href="https://confidentialcomputing.io/white-papers/" target="_blank">https://confidentialcomputing.io/white-papers/</a></p>
<p>[EDK II] <a href="https://github.com/tianocore/edk2" target="_blank">https://github.com/tianocore/edk2</a></p>
<p>[EDK II TPM2] Jiewen Yao, Vincent Zimmer, &quot;A Tour Beyond BIOS - with
the UEFI TPM2 Support in EDK II&quot;, 2014,
<a href="https://software.intel.com/sites/default/files/managed/94/2d/a_tour_beyond_bios_implementing_tpm2_support_in_edkii.pdf" target="_blank">https://software.intel.com/sites/default/files/managed/94/2d/a_tour_beyond_bios_implementing_tpm2_support_in_edkii.pdf</a></p>
<p>[EDK II Tcg2DumpLog] Tcg2DumpLog tool,
<a href="https://github.com/jyao1/EdkiiShellTool/tree/master/EdkiiShellToolPkg/Tcg2DumpLog" target="_blank">https://github.com/jyao1/EdkiiShellTool/tree/master/EdkiiShellToolPkg/Tcg2DumpLog</a></p>
<p>[EDK II TPM Emulator] EDK II TPM Emulator,
<a href="https://github.com/jyao1/edk2/tree/feature_tpm_emulator/EmulatorPkg/Tpm2" target="_blank">https://github.com/jyao1/edk2/tree/feature_tpm_emulator/EmulatorPkg/Tpm2</a></p>
<p>[UEFI TCTI] <a href="https://github.com/tpm2-software/tpm2-tcti-uefi" target="_blank">https://github.com/tpm2-software/tpm2-tcti-uefi</a></p>
<p>[EDK II Tpm2TssPkg] EDK II Tpm2TssPkg,
<a href="https://github.com/flihp/edk2/tree/tpm2-tss/Tpm2TssPkg" target="_blank">https://github.com/flihp/edk2/tree/tpm2-tss/Tpm2TssPkg</a></p>
<p>[EDK II DeviceSecurityPkg] EDK II DeviceSecurityPkg,
<a href="https://github.com/jyao1/edk2/tree/DeviceSecurity/DeviceSecurityPkg" target="_blank">https://github.com/jyao1/edk2/tree/DeviceSecurity/DeviceSecurityPkg</a></p>
<p>[EDK II FSP Manifest Tool] FSP manifest tool,
<a href="https://github.com/jyao1/FSP/tree/FspAttestation/Tools/ManifestTools" target="_blank">https://github.com/jyao1/FSP/tree/FspAttestation/Tools/ManifestTools</a></p>
<p>[TPM2 Software] <a href="https://github.com/tpm2-software" target="_blank">https://github.com/tpm2-software</a></p>
<p>[Remote Attestation]
<a href="https://tpm2-software.github.io/tpm2-tss/getting-started/2019/12/18/Remote-Attestation.html" target="_blank">https://tpm2-software.github.io/tpm2-tss/getting-started/2019/12/18/Remote-Attestation.html</a></p>
<p>[Microsoft TPM2 Simulator]
<a href="https://github.com/microsoft/ms-tpm-20-ref" target="_blank">https://github.com/microsoft/ms-tpm-20-ref</a></p>
<p>[TCG TPM2 Simulator] <a href="https://github.com/stwagnr/tpm2simulator" target="_blank">https://github.com/stwagnr/tpm2simulator</a></p>
<p>[OpenPower Trusted Boot] OpenPOWER secure and trusted boot , Part 1:
Using trusted boot on IBM OpenPOWER servers, 2017,
<a href="https://developer.ibm.com/articles/trusted-boot-openpower/" target="_blank">https://developer.ibm.com/articles/trusted-boot-openpower/</a></p>
<p>[coreboot] <a href="https://review.coreboot.org/" target="_blank">https://review.coreboot.org/</a>,
<a href="https://github.com/coreboot" target="_blank">https://github.com/coreboot</a></p>
<p>[coreboot MeasuredBoot] coreboot Measured Boot,
<a href="https://doc.coreboot.org/security/vboot/measured_boot.html" target="_blank">https://doc.coreboot.org/security/vboot/measured_boot.html</a></p>
<p>[GRUB] <a href="http://www.gnu.org/software/grub/" target="_blank">http://www.gnu.org/software/grub/</a>,
<a href="https://github.com/rhboot/shim" target="_blank">https://github.com/rhboot/shim</a></p>
<p>[Grub Measured Boot]
<a href="https://www.gnu.org/software/grub/manual/grub/html_node/Measured-Boot.html" target="_blank">https://www.gnu.org/software/grub/manual/grub/html_node/Measured-Boot.html</a></p>
<p>[openspdm] <a href="https://github.com/jyao1/openspdm" target="_blank">https://github.com/jyao1/openspdm</a></p>
<p>[Windows BitLocker] Windows BitLocker Group Policy Setting,</p>
<p><a href="https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-group-policy-settings" target="_blank">https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-group-policy-settings</a></p>
<p>[UEFI TCG] Vincent Zimmer, Shiva Dasari (IBM), Sean Brogan (IBM),
&quot;Trusted Platforms:  UEFI, PI, and TCG-based firmware,&quot; Intel/IBM
whitepaper, September 2009,
<a href="http://www.cs.berkeley.edu/~kubitron/courses/cs194-24-S14/hand-outs/SF09_EFIS001_UEFI_PI_TCG_White_Paper.pdf" target="_blank">http://www.cs.berkeley.edu/~kubitron/courses/cs194-24-S14/hand-outs/SF09_EFIS001_UEFI_PI_TCG_White_Paper.pdf</a></p>
<p>[TCG-CW] Ned Smith, A Comparison of the trusted Computing Group
Security Model with Clark-Wilson, 2014,
<a href="https://www.semanticscholar.org/paper/A-Comparison-of-the-trusted-Computing-Group-Model-Smith/fa82426d99b86d1040f80b8bd8e0ac4f785b29a6" target="_blank">https://www.semanticscholar.org/paper/A-Comparison-of-the-trusted-Computing-Group-Model-Smith/fa82426d99b86d1040f80b8bd8e0ac4f785b29a6</a></p>
<p>[Windows DMA Protection] Kernel DMA Protection (Memory Access
Protection) for OEMs,</p>
<p><a href="https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-kernel-dma-protection" target="_blank">https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-kernel-dma-protection</a></p>
<p>[Windows Secured-Core PC] Force firmware code to be measured and
attested by Secure Launch on Windows 10,
<a href="https://www.microsoft.com/security/blog/2020/09/01/force-firmware-code-to-be-measured-and-attested-by-secure-launch-on-windows-10/" target="_blank">https://www.microsoft.com/security/blog/2020/09/01/force-firmware-code-to-be-measured-and-attested-by-secure-launch-on-windows-10/</a></p>
<p>[KeyStone] Keystone Enclave, <a href="https://keystone-enclave.org/" target="_blank">https://keystone-enclave.org/</a></p>

                                
                                </section>
                            
                        </div>
                    </div>
                    
                    

<div>
    <hr>
    
      <h2>
        <div style="position:absolute;text-align:left">Understanding the Trusted Boot Chain Implementation</div>
        <div style="position:absolute;width:100%;text-align:center">DRAFT [12/02/2020 10:55:54]</div>
        <div style="text-align:right">Revision 1.0</div>
      </h2>  
    
</div>



                
            </div>

            
                
                <a href="./" class="navigation navigation-prev navigation-unique" aria-label="Previous page: Understanding the Trusted Boot Chain Implementation">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"1 First Chapter","level":"1.2","depth":1,"next":{"title":"Tables","level":"2.1","depth":1,"ref":"","articles":[]},"previous":{"title":"Understanding the Trusted Boot Chain Implementation","level":"1.1","depth":1,"path":"README.md","ref":"README.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{"draft":"yes","title":"Understanding the Trusted Boot Chain Implementation","version":"Revision 1.0"},"plugins":["puml-aleung"],"pluginsConfig":{"puml-aleung":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"chapter1.md","mtime":"2020-12-02T22:55:22.056Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-12-02T22:55:54.850Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

